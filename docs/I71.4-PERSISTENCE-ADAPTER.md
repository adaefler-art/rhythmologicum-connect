# I71.4: Assessment Persistence Adapter - Usage Guide

## Overview

The Assessment Persistence Adapter provides a centralized, type-safe API for handling assessment data persistence with built-in idempotency support. This implementation addresses Issue I71.4 requirements for save/resume functionality with double-tap prevention.

## Architecture

### Components

1. **Persistence Adapter** (`lib/api/assessmentPersistence.ts`)
   - Server-side functions for data persistence
   - Type-safe interfaces
   - Idempotent operations

2. **API Endpoints**
   - `GET /api/assessments/[id]/state` - Load assessment state for resume
   - `POST /api/assessment-answers/save` - Save answer with idempotency

3. **Client Hook** (`lib/hooks/useAssessmentAnswer.ts`)
   - React hook for save operations
   - Automatic clientMutationId generation
   - Error handling and retry support

## Usage

### Server-Side: Using the Persistence Adapter

```typescript
import {
  loadAssessmentRun,
  saveAnswer,
  completeAssessment,
} from '@/lib/api/assessmentPersistence'

// Load assessment state (for resume)
const assessmentRun = await loadAssessmentRun(assessmentId)
console.log(assessmentRun.answersByQuestionId) // { q1: 5, q2: 7 }
console.log(assessmentRun.stepIndex) // 2

// Save an answer with idempotency
const result = await saveAnswer(
  assessmentId,
  'stress_level',
  7,
  'unique-mutation-id-123',
)

if (result.success) {
  console.log('Answer saved:', result.answerId)
} else {
  console.error('Save failed:', result.error)
}

// Complete assessment
const completeResult = await completeAssessment(assessmentId)
```

### Client-Side: Using the Hook

```typescript
import { useAssessmentAnswer } from '@/lib/hooks/useAssessmentAnswer'

function AssessmentQuestion() {
  const { saveAnswer, saveState, lastError, retry } = useAssessmentAnswer()

  const handleAnswer = async (value: number) => {
    const result = await saveAnswer({
      assessmentId: 'uuid-123',
      questionId: 'stress_level',
      answerValue: value,
      // clientMutationId is auto-generated if not provided
    })

    if (result.success) {
      console.log('Saved!')
      if (result.cached) {
        console.log('This was a duplicate request (idempotency)')
      }
    }
  }

  return (
    <div>
      {saveState === 'error' && (
        <div>
          <p>Error: {lastError}</p>
          <button onClick={retry}>Retry</button>
        </div>
      )}

      <button
        onClick={() => handleAnswer(7)}
        disabled={saveState === 'saving'}
      >
        {saveState === 'saving' ? 'Saving...' : 'Answer 7'}
      </button>
    </div>
  )
}
```

### Loading Assessment State on Resume

```typescript
// In your component that resumes assessment
useEffect(() => {
  async function loadState() {
    const response = await fetch(`/api/assessments/${assessmentId}/state`, {
      credentials: 'include',
    })

    if (response.ok) {
      const { data } = await response.json()
      
      // Restore answers
      setAnswers(data.answersByQuestionId)
      
      // Restore step
      setCurrentStep(data.stepIndex)
      
      console.log(`Resumed at step ${data.stepIndex}`)
    }
  }

  loadState()
}, [assessmentId])
```

## Idempotency

### How It Works

1. **Client generates unique ID**: Each save operation gets a unique `clientMutationId`
2. **Server checks for duplicates**: Before processing, server checks if this mutation was already processed
3. **Cached response**: If duplicate detected, server returns the cached response from first request
4. **24-hour TTL**: Idempotency keys expire after 24 hours

### Benefits

- ✅ Double-tap "Continue" button doesn't create duplicate saves
- ✅ Network retry doesn't duplicate data
- ✅ Safe to retry failed requests
- ✅ Consistent responses for same operation

### Example: Double-Tap Prevention

```typescript
// User taps "Continue" twice rapidly
const mutationId = 'same-id-for-both-taps'

// First tap
await saveAnswer(assessmentId, 'q1', 5, mutationId)
// → Processes normally, saves to DB

// Second tap (within 24 hours)
await saveAnswer(assessmentId, 'q1', 5, mutationId)
// → Returns cached response, no DB write
```

## Error Handling

### Error States

The `useAssessmentAnswer` hook provides the following states:

- `idle` - No operation in progress
- `saving` - Save operation in progress
- `saved` - Save completed successfully (auto-transitions to idle)
- `error` - Save failed

### Error Recovery

```typescript
const { saveAnswer, saveState, lastError, retry } = useAssessmentAnswer()

if (saveState === 'error') {
  // Show error UI
  console.error('Save failed:', lastError)
  
  // User can retry
  await retry() // Retries the last failed operation
}
```

### Network Error Detection

The hook automatically detects network errors and provides appropriate error messages:

```typescript
// Network failure
if (lastError?.includes('Netzwerkfehler')) {
  // Show offline indicator or network error message
}
```

## API Response Format

### Success Response

```json
{
  "success": true,
  "data": {
    "id": "answer-uuid",
    "assessment_id": "assessment-uuid",
    "question_id": "stress_level",
    "answer_value": 7
  },
  "schemaVersion": "1.0.0"
}
```

### Error Response

```json
{
  "success": false,
  "error": {
    "code": "ASSESSMENT_COMPLETED",
    "message": "Assessment ist bereits abgeschlossen"
  }
}
```

## Testing

### Unit Tests

```bash
npm test -- assessmentPersistence.test.ts
npm test -- useAssessmentAnswer.test.ts
```

### Integration Tests

```bash
npm test -- saveResumeIntegration.test.ts
```

### Manual Testing Checklist

- [ ] Start assessment, answer Q3, reload → answer visible
- [ ] Double-tap "Continue" → only one save operation
- [ ] Simulate offline → error shown with retry button
- [ ] Click retry → operation succeeds when back online
- [ ] Complete assessment → cannot save more answers

## Migration Guide

### From Direct Supabase Calls

**Before:**
```typescript
const { data, error } = await supabase
  .from('assessment_answers')
  .upsert({
    assessment_id: assessmentId,
    question_id: questionId,
    answer_value: value,
  })
```

**After:**
```typescript
const result = await saveAnswer(
  assessmentId,
  questionId,
  value,
  crypto.randomUUID(),
)
```

### From Old Save Endpoint

**Before:**
```typescript
await fetch('/api/assessment-answers/save', {
  method: 'POST',
  body: JSON.stringify({
    assessmentId,
    questionId,
    answerValue,
  }),
})
```

**After:**
```typescript
// clientMutationId is now automatically added
const { saveAnswer } = useAssessmentAnswer()
await saveAnswer({ assessmentId, questionId, answerValue })
```

## Troubleshooting

### Issue: Answers not persisting

**Check:**
1. Is the assessment still `in_progress`? (Cannot save to completed assessments)
2. Is the user authenticated?
3. Does the user own the assessment?
4. Check browser console for errors

### Issue: Duplicate saves despite idempotency

**Check:**
1. Is `clientMutationId` being passed correctly?
2. Are you generating a new ID for each unique operation?
3. Check server logs for idempotency key storage errors

### Issue: Resume not working

**Check:**
1. Is the `/api/assessments/[id]/state` endpoint accessible?
2. Is the assessment ID correct?
3. Check browser console for fetch errors
4. Verify answers exist in database

## Performance Considerations

- **Debouncing**: The hook includes 300ms debouncing to prevent excessive API calls
- **Caching**: Idempotency provides automatic response caching for 24 hours
- **Database**: Upsert operations prevent duplicate answer rows
- **Index**: `assessment_answers` table has unique index on `(assessment_id, question_id)`

## Security

- ✅ Authentication required for all operations
- ✅ Ownership verification (user must own the assessment)
- ✅ RLS policies on database tables
- ✅ Server-side validation of all inputs
- ✅ Idempotency keys scoped to user ID

## Related Documentation

- [Epic B Architecture](../docs/IMPLEMENTATION_SUMMARY.md)
- [Database Schema](../schema/schema.sql)
- [API Contracts](./lib/api/contracts/patient/README.md)
- [Issue I71.4](https://github.com/adaefler-art/rhythmologicum-connect/issues/I71.4)

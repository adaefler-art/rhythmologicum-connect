{"version":3,"sources":["../../../../../../lib/contracts/registry.ts","../../../../../../apps/rhythm-patient-ui/app/patient/funnel/%5Bslug%5D/client.tsx/__nextjs-internal-proxy.mjs","../../../../../../apps/rhythm-patient-ui/app/patient/funnel/%5Bslug%5D/page.tsx","../../../../../../lib/utils/contentResolver.ts"],"sourcesContent":["/**\n * Contract Registry - Canonical Identifiers\n * \n * This file serves as the single source of truth for all critical string identifiers\n * used throughout the application. All new identifiers MUST be added here to prevent\n * \"fantasy names\" and ensure consistency.\n * \n * **IMPORTANT**: This file is protected by CODEOWNERS. Any changes require review.\n * \n * Usage:\n * ```typescript\n * import { ASSESSMENT_STATUS, FUNNEL_SLUG, USER_ROLE } from '@/lib/contracts/registry'\n * \n * const status: AssessmentStatus = ASSESSMENT_STATUS.IN_PROGRESS\n * const funnel: FunnelSlug = FUNNEL_SLUG.STRESS_ASSESSMENT\n * ```\n */\n\n// ============================================================\n// Assessment Statuses\n// ============================================================\n\n/**\n * Valid statuses for assessments\n */\nexport const ASSESSMENT_STATUS = {\n  IN_PROGRESS: 'in_progress',\n  COMPLETED: 'completed',\n} as const\n\nexport type AssessmentStatus = typeof ASSESSMENT_STATUS[keyof typeof ASSESSMENT_STATUS]\n\n// ============================================================\n// Content Page Statuses\n// ============================================================\n\n/**\n * Valid statuses for content pages\n */\nexport const CONTENT_STATUS = {\n  DRAFT: 'draft',\n  PUBLISHED: 'published',\n  ARCHIVED: 'archived',\n} as const\n\nexport type ContentStatus = typeof CONTENT_STATUS[keyof typeof CONTENT_STATUS]\n\n// ============================================================\n// Pillar Keys (7-Pillar Model)\n// ============================================================\n\n/**\n * Valid pillar keys for funnel taxonomy (7-Pillar Wellness Model)\n */\nexport const PILLAR_KEY = {\n  NUTRITION: 'nutrition',\n  MOVEMENT: 'movement',\n  SLEEP: 'sleep',\n  MENTAL_HEALTH: 'mental-health',\n  SOCIAL: 'social',\n  MEANING: 'meaning',\n  PREVENTION: 'prevention',\n} as const\n\nexport type PillarKey = typeof PILLAR_KEY[keyof typeof PILLAR_KEY]\n\n// ============================================================\n// Funnel Slugs\n// ============================================================\n\n/**\n * Valid funnel slugs\n * The canonical slug is the primary identifier\n * Legacy aliases are maintained for backward compatibility\n */\nexport const FUNNEL_SLUG = {\n  STRESS_ASSESSMENT: 'stress-assessment',\n  CARDIOVASCULAR_AGE: 'cardiovascular-age',\n  SLEEP_QUALITY: 'sleep-quality',\n  HEART_HEALTH_NUTRITION: 'heart-health-nutrition',\n  // Legacy aliases - deprecated but maintained for compatibility\n  STRESS: 'stress',\n  STRESS_CHECK: 'stress-check',\n  STRESS_CHECK_V2: 'stress-check-v2',\n} as const\n\nexport type FunnelSlug = typeof FUNNEL_SLUG[keyof typeof FUNNEL_SLUG]\n\n/**\n * Maps legacy funnel slugs to their canonical equivalents\n * Uses lowercase keys for case-insensitive matching\n */\nexport const FUNNEL_SLUG_ALIASES: Record<string, string> = {\n  'stress': FUNNEL_SLUG.STRESS_ASSESSMENT,\n  'stress-check': FUNNEL_SLUG.STRESS_ASSESSMENT,\n  'stress-check-v2': FUNNEL_SLUG.STRESS_ASSESSMENT,\n}\n\n/**\n * Resolves a funnel slug to its canonical form\n * Normalizes input by trimming and converting to lowercase for deterministic matching\n * \n * @param slug - The funnel slug to resolve (case-insensitive, whitespace trimmed)\n * @returns The canonical slug or the normalized input if no mapping exists\n */\nexport function getCanonicalFunnelSlug(slug: string): string {\n  const normalized = slug.toLowerCase().trim()\n  return FUNNEL_SLUG_ALIASES[normalized] || normalized\n}\n\n/**\n * Checks if a funnel slug is known in the registry\n * A funnel is \"known\" if it exists in FUNNEL_SLUG values (canonical or legacy)\n * \n * @param slug - The funnel slug to check (case-insensitive, whitespace trimmed)\n * @returns true if the funnel slug is registered, false otherwise\n */\nexport function isKnownFunnelSlug(slug: string): boolean {\n  const canonical = getCanonicalFunnelSlug(slug)\n  const allSlugs = Object.values(FUNNEL_SLUG)\n  return allSlugs.includes(canonical as FunnelSlug)\n}\n\n// ============================================================\n// Node/Step Types\n// ============================================================\n\n/**\n * Valid node/step types for funnel steps\n * These correspond to the 'type' field in the funnel_steps table\n */\nexport const NODE_TYPE = {\n  QUESTION_STEP: 'question_step',\n  FORM: 'form',\n  INFO_STEP: 'info_step',\n  INFO: 'info',\n  CONTENT_PAGE: 'content_page',\n  SUMMARY: 'summary',\n  OTHER: 'other',\n} as const\n\nexport type NodeType = typeof NODE_TYPE[keyof typeof NODE_TYPE]\n\n// ============================================================\n// User Roles\n// ============================================================\n\n/**\n * Valid user roles\n * These are stored in auth.users.raw_app_meta_data.role\n */\nexport const USER_ROLE = {\n  PATIENT: 'patient',\n  CLINICIAN: 'clinician',\n  ADMIN: 'admin',\n  NURSE: 'nurse',\n} as const\n\nexport type UserRole = typeof USER_ROLE[keyof typeof USER_ROLE]\n\n// ============================================================\n// Question Types\n// ============================================================\n\n/**\n * Valid question types\n * These correspond to the 'question_type' field in the questions table\n */\nexport const QUESTION_TYPE = {\n  RADIO: 'radio',\n  CHECKBOX: 'checkbox',\n  TEXT: 'text',\n  TEXTAREA: 'textarea',\n  NUMBER: 'number',\n  SCALE: 'scale',\n  SLIDER: 'slider',\n} as const\n\nexport type QuestionType = typeof QUESTION_TYPE[keyof typeof QUESTION_TYPE]\n\n// ============================================================\n// Patient Demographics\n// ============================================================\n\n/**\n * Valid sex/gender options for patient profiles\n * These correspond to the 'sex' field in the patient_profiles table\n */\nexport const PATIENT_SEX = {\n  MALE: 'male',\n  FEMALE: 'female',\n  OTHER: 'other',\n  PREFER_NOT_TO_SAY: 'prefer_not_to_say',\n} as const\n\nexport type PatientSex = typeof PATIENT_SEX[keyof typeof PATIENT_SEX]\n\n// ============================================================\n// Feature Flag Names\n// ============================================================\n\n/**\n * Valid feature flag names (without NEXT_PUBLIC_FEATURE_ prefix)\n */\nexport const FEATURE_FLAG = {\n  AMY_ENABLED: 'AMY_ENABLED',\n  CLINICIAN_DASHBOARD_ENABLED: 'CLINICIAN_DASHBOARD_ENABLED',\n  CHARTS_ENABLED: 'CHARTS_ENABLED',\n} as const\n\nexport type FeatureFlag = typeof FEATURE_FLAG[keyof typeof FEATURE_FLAG]\n\n// ============================================================\n// Helper Functions\n// ============================================================\n\n/**\n * Type guard to check if a value is a valid assessment status\n */\nexport function isValidAssessmentStatus(value: unknown): value is AssessmentStatus {\n  return typeof value === 'string' && Object.values(ASSESSMENT_STATUS).includes(value as AssessmentStatus)\n}\n\n/**\n * Type guard to check if a value is a valid content status\n */\nexport function isValidContentStatus(value: unknown): value is ContentStatus {\n  return typeof value === 'string' && Object.values(CONTENT_STATUS).includes(value as ContentStatus)\n}\n\n/**\n * Type guard to check if a value is a valid user role\n */\nexport function isValidUserRole(value: unknown): value is UserRole {\n  return typeof value === 'string' && Object.values(USER_ROLE).includes(value as UserRole)\n}\n\n/**\n * Type guard to check if a value is a valid node type\n */\nexport function isValidNodeType(value: unknown): value is NodeType {\n  return typeof value === 'string' && Object.values(NODE_TYPE).includes(value as NodeType)\n}\n\n/**\n * Type guard to check if a value is a valid pillar key\n */\nexport function isValidPillarKey(value: unknown): value is PillarKey {\n  return typeof value === 'string' && Object.values(PILLAR_KEY).includes(value as PillarKey)\n}\n\n/**\n * Type guard to check if a value is a valid patient sex option\n */\nexport function isValidPatientSex(value: unknown): value is PatientSex {\n  return typeof value === 'string' && Object.values(PATIENT_SEX).includes(value as PatientSex)\n}\n\n// ============================================================\n// Audit Log Entity Types\n// ============================================================\n\n/**\n * Valid entity types for audit logging\n * These correspond to the 'entity_type' field in the audit_log table\n */\nexport const AUDIT_ENTITY_TYPE = {\n  ASSESSMENT: 'assessment',\n  REPORT: 'report',\n  TASK: 'task',\n  FUNNEL_VERSION: 'funnel_version',\n  FUNNEL_CATALOG: 'funnel_catalog',\n  CONFIG: 'config',\n  CONSENT: 'consent',\n  ORGANIZATION: 'organization',\n  USER_ORG_MEMBERSHIP: 'user_org_membership',\n  CLINICIAN_ASSIGNMENT: 'clinician_assignment',\n  DOCUMENT: 'document', // V05-I04.3: Document confirmation tracking\n  PROCESSING_JOB: 'processing_job', // V05-I05.1: Processing job orchestration\n  REVIEW_RECORD: 'review_record', // V05-I05.7: Medical review records\n  PRE_SCREENING_CALL: 'pre_screening_call', // V05-I08.2: Pre-screening call records\n  DEVICE_SHIPMENT: 'device_shipment', // V05-I08.3: Shipment tracking\n  SUPPORT_CASE: 'support_case', // V05-I08.4: Support case documentation\n  ACCOUNT: 'account', // V05-I10.2: Account lifecycle (deletion/retention)\n} as const\n\nexport type AuditEntityType = typeof AUDIT_ENTITY_TYPE[keyof typeof AUDIT_ENTITY_TYPE]\n\n// ============================================================\n// Audit Log Actions\n// ============================================================\n\n/**\n * Valid actions for audit logging\n * These correspond to the 'action' field in the audit_log table\n */\nexport const AUDIT_ACTION = {\n  CREATE: 'create',\n  UPDATE: 'update',\n  DELETE: 'delete',\n  APPROVE: 'approve',\n  REJECT: 'reject',\n  REQUEST_CHANGES: 'request_changes', // V05-I05.7: Review workflow\n  GENERATE: 'generate',\n  FLAG: 'flag',\n  ASSIGN: 'assign',\n  ACTIVATE: 'activate',\n  DEACTIVATE: 'deactivate',\n  ROLLOUT: 'rollout',\n  COMPLETE: 'complete',\n  ESCALATE: 'escalate', // V05-I08.4: Support case escalation\n  DELETION_REQUEST: 'deletion_request', // V05-I10.2: User requested account deletion\n  DELETION_CANCEL: 'deletion_cancel', // V05-I10.2: User cancelled deletion request\n  DELETION_EXECUTE: 'deletion_execute', // V05-I10.2: System executed account deletion\n  ANONYMIZE: 'anonymize', // V05-I10.2: Records anonymized instead of deleted\n} as const\n\nexport type AuditAction = typeof AUDIT_ACTION[keyof typeof AUDIT_ACTION]\n\n// ============================================================\n// Audit Log Sources\n// ============================================================\n\n/**\n * Valid sources for audit logging\n * These correspond to the 'source' field in the audit_log table\n */\nexport const AUDIT_SOURCE = {\n  API: 'api',\n  JOB: 'job',\n  ADMIN_UI: 'admin-ui',\n  SYSTEM: 'system',\n} as const\n\nexport type AuditSource = typeof AUDIT_SOURCE[keyof typeof AUDIT_SOURCE]\n\n// ============================================================\n// Audit Type Guards\n// ============================================================\n\n/**\n * Type guard to check if a value is a valid audit entity type\n */\nexport function isValidAuditEntityType(value: unknown): value is AuditEntityType {\n  return typeof value === 'string' && Object.values(AUDIT_ENTITY_TYPE).includes(value as AuditEntityType)\n}\n\n/**\n * Type guard to check if a value is a valid audit action\n */\nexport function isValidAuditAction(value: unknown): value is AuditAction {\n  return typeof value === 'string' && Object.values(AUDIT_ACTION).includes(value as AuditAction)\n}\n\n/**\n * Type guard to check if a value is a valid audit source\n */\nexport function isValidAuditSource(value: unknown): value is AuditSource {\n  return typeof value === 'string' && Object.values(AUDIT_SOURCE).includes(value as AuditSource)\n}\n\n// ============================================================\n// Program Tier Levels (TV05_01D)\n// ============================================================\n\n/**\n * Valid program tier levels based on Thomas' journey model\n * These map the 3-tier patient journey to platform capabilities\n */\nexport const PROGRAM_TIER = {\n  /**\n   * Tier 1 (Essential): Basic stress/resilience assessment\n   * Focus: Initial assessment, baseline data collection\n   */\n  TIER_1_ESSENTIAL: 'tier-1-essential',\n  \n  /**\n   * Tier 2.5 (Enhanced): Extended monitoring with nurse touchpoints\n   * Focus: Regular check-ins, progress tracking\n   */\n  TIER_2_5_ENHANCED: 'tier-2-5-enhanced',\n  \n  /**\n   * Tier 2 (Comprehensive): Full program with intensive support\n   * Focus: Comprehensive care, multiple pillars, frequent touchpoints\n   */\n  TIER_2_COMPREHENSIVE: 'tier-2-comprehensive',\n} as const\n\nexport type ProgramTier = typeof PROGRAM_TIER[keyof typeof PROGRAM_TIER]\n\n/**\n * Type guard to check if a value is a valid program tier\n */\nexport function isValidProgramTier(value: unknown): value is ProgramTier {\n  return typeof value === 'string' && Object.values(PROGRAM_TIER).includes(value as ProgramTier)\n}\n\n// ============================================================\n// Document Extraction Versions (V05-I04.2)\n// ============================================================\n\n/**\n * Valid extractor versions for AI document extraction\n * Format: vMAJOR.MINOR.PATCH\n * Update when extraction logic or prompts change\n */\nexport const EXTRACTOR_VERSION = {\n  /**\n   * v1.0.0: Initial extraction pipeline\n   * - Basic lab value extraction\n   * - Medication list extraction\n   * - Confidence scoring\n   */\n  V1_0_0: 'v1.0.0',\n} as const\n\nexport type ExtractorVersion = typeof EXTRACTOR_VERSION[keyof typeof EXTRACTOR_VERSION]\n\n/**\n * Current extractor version (latest)\n */\nexport const CURRENT_EXTRACTOR_VERSION = EXTRACTOR_VERSION.V1_0_0\n\n/**\n * Type guard to check if a value is a valid extractor version\n */\nexport function isValidExtractorVersion(value: unknown): value is ExtractorVersion {\n  return typeof value === 'string' && Object.values(EXTRACTOR_VERSION).includes(value as ExtractorVersion)\n}\n\n// ============================================================\n// Processing Stages & Status (V05-I05.1)\n// ============================================================\n\n/**\n * Valid processing stages for job orchestrator\n * Jobs progress deterministically through these stages\n */\nexport const PROCESSING_STAGE = {\n  PENDING: 'pending',\n  RISK: 'risk',\n  RANKING: 'ranking',\n  CONTENT: 'content',\n  VALIDATION: 'validation',\n  REVIEW: 'review',\n  PDF: 'pdf',\n  DELIVERY: 'delivery',\n  COMPLETED: 'completed',\n  FAILED: 'failed',\n} as const\n\nexport type ProcessingStage = typeof PROCESSING_STAGE[keyof typeof PROCESSING_STAGE]\n\n/**\n * Valid processing statuses for job orchestrator\n */\nexport const PROCESSING_STATUS = {\n  QUEUED: 'queued',\n  IN_PROGRESS: 'in_progress',\n  COMPLETED: 'completed',\n  FAILED: 'failed',\n} as const\n\nexport type ProcessingStatus = typeof PROCESSING_STATUS[keyof typeof PROCESSING_STATUS]\n\n/**\n * Type guard to check if a value is a valid processing stage\n */\nexport function isValidProcessingStage(value: unknown): value is ProcessingStage {\n  return typeof value === 'string' && Object.values(PROCESSING_STAGE).includes(value as ProcessingStage)\n}\n\n/**\n * Type guard to check if a value is a valid processing status\n */\nexport function isValidProcessingStatus(value: unknown): value is ProcessingStatus {\n  return typeof value === 'string' && Object.values(PROCESSING_STATUS).includes(value as ProcessingStatus)\n}\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/apps/rhythm-patient-ui/app/patient/funnel/[slug]/client.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/apps/rhythm-patient-ui/app/patient/funnel/[slug]/client.tsx\",\n    \"default\",\n);\n","import { redirect } from 'next/navigation'\nimport { createServerSupabaseClient } from '@/lib/db/supabase.server'\nimport { enforceDashboardFirst } from '@/lib/utils/dashboardFirstPolicy'\nimport FunnelClient from './client'\nimport { getContentPage } from '@/lib/utils/contentResolver'\n\ntype PageProps = {\n  params: Promise<{ slug: string }>\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}\n\nexport default async function FunnelPage({ params, searchParams }: PageProps) {\n  const { slug } = await params\n  const search = await searchParams\n  const skipIntro = search.skipIntro === 'true'\n\n  // Create Supabase server client (canonical)\n  const supabase = await createServerSupabaseClient()\n\n  // E6.5.1 AC3: Check authentication FIRST (401-first, no DB calls before auth)\n  const {\n    data: { user },\n  } = await supabase.auth.getUser()\n\n  if (!user) {\n    redirect('/')\n  }\n\n  // E6.5.1 AC2: Enforce dashboard-first policy\n  // Prevent direct deep-linking to funnel routes\n  const pathname = `/patient/funnel/${slug}`\n  const redirectUrl = await enforceDashboardFirst(pathname)\n  \n  if (redirectUrl) {\n    redirect(redirectUrl)\n  }\n\n  // Check for intro page (F6 - Intro-Page Integration)\n  // Only redirect to intro if:\n  // 1. skipIntro is not set\n  // 2. An intro page exists for this funnel\n  if (!skipIntro) {\n    try {\n      const introResult = await getContentPage({\n        funnel: slug,\n        category: 'intro',\n        includeDrafts: false,\n      })\n\n      if (introResult.page) {\n        // Intro page exists, redirect to intro route\n        redirect(`/patient/funnel/${slug}/intro`)\n      }\n    } catch (error) {\n      // If intro check fails, continue to assessment\n      console.warn('Failed to check for intro page:', error)\n    }\n  }\n\n  // Render client component with slug\n  return <FunnelClient slug={slug} />\n}\n","import { createClient, type SupabaseClient } from '@supabase/supabase-js'\nimport type { ContentPage } from '@/lib/types/content'\nimport { FUNNEL_SLUG_ALIASES, getCanonicalFunnelSlug, isKnownFunnelSlug } from '@/lib/contracts/registry'\nimport { env } from '@/lib/env'\n\n/**\n * F5 - Content Resolver: Core utility for Funnel Integration\n * \n * This module provides the central API for selecting appropriate content pages\n * based on funnel, category, and optional slug parameters, with intelligent\n * fallback handling.\n */\n\n/**\n * Options for content page resolution\n */\nexport type ContentResolverOptions = {\n  /** Funnel slug or UUID */\n  funnel: string\n  /** Optional category filter (e.g., 'intro', 'info', 'result') */\n  category?: string\n  /** Optional specific page slug */\n  slug?: string\n  /** Whether to include draft pages (default: false) */\n  includeDrafts?: boolean\n}\n\n/**\n * Result of content page resolution\n */\nexport type ContentResolverResult = {\n  /** The resolved content page, or null if not found */\n  page: ContentPage | null\n  /** The resolution strategy that was used */\n  strategy: 'exact-match' | 'category-default' | 'funnel-default' | 'not-found'\n  /** Any error that occurred during resolution (non-fatal) */\n  error?: string\n}\n\n/**\n * Initialize Supabase client for content resolution\n * Uses service role key for unrestricted access to published content\n */\nfunction getSupabaseClient() {\n  const supabaseUrl = env.NEXT_PUBLIC_SUPABASE_URL\n  const supabaseKey = env.SUPABASE_SERVICE_ROLE_KEY || env.NEXT_PUBLIC_SUPABASE_ANON_KEY\n\n  if (!supabaseUrl || !supabaseKey) {\n    throw new Error('Supabase configuration missing')\n  }\n\n  return createClient(supabaseUrl, supabaseKey, {\n    auth: { persistSession: false },\n  })\n}\n\n/**\n * Check if a string is a valid UUID\n */\nfunction isUUID(value: string): boolean {\n  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i\n  return uuidRegex.test(value)\n}\n\n/**\n * Type for funnel query result\n */\ntype FunnelQueryResult = {\n  id: string\n}\n\nconst FUNNEL_NOT_FOUND = 'FUNNEL_NOT_FOUND'\nconst FUNNEL_CATALOG_ONLY = 'FUNNEL_CATALOG_ONLY'\n\n/**\n * Resolve funnel slug or UUID to funnel ID\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function resolveFunnelId(supabase: SupabaseClient<any>, funnelIdentifier: string): Promise<string | null> {\n  try {\n    // If it's already a UUID, return it\n    if (isUUID(funnelIdentifier)) {\n      return funnelIdentifier\n    }\n\n    // Otherwise, look up by slug.\n    // Canonical slugs may be backed by legacy funnel rows in the DB.\n    const normalized = funnelIdentifier.toLowerCase().trim()\n    const canonical = getCanonicalFunnelSlug(normalized)\n    const legacySlugs = Object.entries(FUNNEL_SLUG_ALIASES)\n      .filter(([, mapped]) => mapped === canonical)\n      .map(([legacy]) => legacy)\n\n    const candidates = Array.from(new Set([normalized, canonical, ...legacySlugs]))\n\n    for (const candidate of candidates) {\n      const { data: funnel } = await supabase\n        .from('funnels')\n        .select('id')\n        .eq('slug', candidate)\n        .maybeSingle()\n\n      if (funnel?.id) {\n        return (funnel as FunnelQueryResult).id\n      }\n    }\n\n    return null\n  } catch (error) {\n    console.error('[CONTENT_RESOLVER_RESOLVE_FUNNEL_ID_FAILED]')\n    return null\n  }\n}\n\n/**\n * Main Content Resolver API\n * \n * Fetches the most appropriate content page based on funnel, category, and slug.\n * Implements intelligent fallback logic:\n * \n * 1. **Exact Match**: funnel + category + slug\n * 2. **Category Default**: funnel + category, highest priority\n * 3. **Funnel Default**: funnel only, highest priority\n * 4. **Not Found**: Returns null gracefully\n * \n * @param options - Resolution options (funnel, category, slug)\n * @returns ContentResolverResult with page and resolution strategy\n * \n * @example\n * ```typescript\n * // Get a specific page by slug\n * const result = await getContentPage({\n *   funnel: 'stress-assessment',\n *   category: 'intro',\n *   slug: 'was-ist-stress'\n * })\n * \n * // Get default intro page for funnel\n * const result = await getContentPage({\n *   funnel: 'stress-assessment',\n *   category: 'intro'\n * })\n * \n * // Get any default page for funnel\n * const result = await getContentPage({\n *   funnel: 'stress-assessment'\n * })\n * ```\n */\nexport async function getContentPage(\n  options: ContentResolverOptions,\n): Promise<ContentResolverResult> {\n  try {\n    const supabase = getSupabaseClient()\n    const { funnel, category, slug, includeDrafts = false } = options\n\n    // Resolve funnel to UUID\n    const funnelId = await resolveFunnelId(supabase, funnel)\n    if (!funnelId) {\n      // V0.5 P0 Fix: Check if funnel is known in the registry before returning FUNNEL_NOT_FOUND.\n      // If it's in the registry but not in DB, it's a known funnel with missing content.\n      if (!isUUID(funnel) && isKnownFunnelSlug(funnel)) {\n        // Funnel is registered but not yet in DB - treat as known funnel with no content\n        return {\n          page: null,\n          strategy: 'not-found',\n          error: FUNNEL_CATALOG_ONLY,\n        }\n      }\n\n      // If the funnel exists in funnels_catalog but isn't fully defined in funnels yet,\n      // treat this as \"no content\" rather than \"unknown funnel\".\n      if (!isUUID(funnel)) {\n        const normalized = funnel.toLowerCase().trim()\n        const canonical = getCanonicalFunnelSlug(normalized)\n        const legacySlugs = Object.entries(FUNNEL_SLUG_ALIASES)\n          .filter(([, mapped]) => mapped === canonical)\n          .map(([legacy]) => legacy)\n\n        const candidates = Array.from(new Set([normalized, canonical, ...legacySlugs]))\n\n        const { data: catalogFunnel } = await supabase\n          .from('funnels_catalog')\n          .select('id')\n          .in('slug', candidates)\n          .limit(1)\n          .maybeSingle()\n\n        if (catalogFunnel?.id) {\n          return {\n            page: null,\n            strategy: 'not-found',\n            error: FUNNEL_CATALOG_ONLY,\n          }\n        }\n      }\n\n      return {\n        page: null,\n        strategy: 'not-found',\n        error: FUNNEL_NOT_FOUND,\n      }\n    }\n\n    // Build base query\n    let query = supabase\n      .from('content_pages')\n      .select('*')\n      .eq('funnel_id', funnelId)\n      .is('deleted_at', null)\n\n    // Filter by status unless includeDrafts is true\n    if (!includeDrafts) {\n      query = query.eq('status', 'published')\n    }\n\n    // Strategy 1: Exact match (funnel + category + slug)\n    // Note: If slug is provided without category, it falls through to Strategy 2/3\n    // where slug matching happens implicitly if the page exists\n    if (category && slug) {\n      const { data, error } = await query\n        .eq('category', category)\n        .eq('slug', slug)\n        .single()\n\n      if (!error && data) {\n        return {\n          page: data as ContentPage,\n          strategy: 'exact-match',\n        }\n      }\n    }\n\n    // Strategy 2: Category default (funnel + category, highest priority)\n    if (category) {\n      const { data, error } = await query\n        .eq('category', category)\n        .order('priority', { ascending: false })\n        .order('created_at', { ascending: false })\n        .limit(1)\n        .maybeSingle()\n\n      if (!error && data) {\n        return {\n          page: data as ContentPage,\n          strategy: 'category-default',\n        }\n      }\n    }\n\n    // Strategy 3: Funnel default (highest priority in funnel)\n    const { data, error } = await query\n      .order('priority', { ascending: false })\n      .order('created_at', { ascending: false })\n      .limit(1)\n      .maybeSingle()\n\n    if (!error && data) {\n      return {\n        page: data as ContentPage,\n        strategy: 'funnel-default',\n      }\n    }\n\n    // Strategy 4: Not found\n    return {\n      page: null,\n      strategy: 'not-found',\n      error: 'No matching content page found',\n    }\n  } catch (error) {\n    // Graceful error handling - never crash\n    console.error('[CONTENT_RESOLVER_ERROR]')\n    return {\n      page: null,\n      strategy: 'not-found',\n      error: 'INTERNAL_ERROR',\n    }\n  }\n}\n\n/**\n * Get multiple content pages for a funnel with optional category filter\n * \n * @param options - Resolution options\n * @returns Array of content pages, ordered by priority (descending)\n * \n * @example\n * ```typescript\n * // Get all intro pages for a funnel\n * const pages = await getContentPages({\n *   funnel: 'stress-assessment',\n *   category: 'intro'\n * })\n * ```\n */\nexport async function getContentPages(\n  options: ContentResolverOptions,\n): Promise<ContentPage[]> {\n  try {\n    const supabase = getSupabaseClient()\n    const { funnel, category, includeDrafts = false } = options\n\n    // Resolve funnel to UUID\n    const funnelId = await resolveFunnelId(supabase, funnel)\n    if (!funnelId) {\n      return []\n    }\n\n    // Build query\n    let query = supabase\n      .from('content_pages')\n      .select('*')\n      .eq('funnel_id', funnelId)\n      .is('deleted_at', null)\n\n    // Filter by status unless includeDrafts is true\n    if (!includeDrafts) {\n      query = query.eq('status', 'published')\n    }\n\n    // Filter by category if provided\n    if (category) {\n      query = query.eq('category', category)\n    }\n\n    // Order by priority and creation date\n    query = query\n      .order('priority', { ascending: false })\n      .order('created_at', { ascending: false })\n\n    const { data, error } = await query\n\n    if (error) {\n      console.error('Error fetching content pages:', error)\n      return []\n    }\n\n    return (data || []) as ContentPage[]\n  } catch (error) {\n    // Graceful error handling\n    console.error('Content Resolver error:', error)\n    return []\n  }\n}\n\n/**\n * Check if a content page exists for the given criteria\n * \n * @param options - Resolution options\n * @returns true if at least one matching page exists\n * \n * @example\n * ```typescript\n * const hasIntro = await hasContentPage({\n *   funnel: 'stress-assessment',\n *   category: 'intro'\n * })\n * ```\n */\nexport async function hasContentPage(\n  options: ContentResolverOptions,\n): Promise<boolean> {\n  const result = await getContentPage(options)\n  return result.page !== null\n}\n"],"names":[],"mappings":"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","ignoreList":[1]}
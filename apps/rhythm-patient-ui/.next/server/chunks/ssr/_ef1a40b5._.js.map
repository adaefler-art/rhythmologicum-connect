{"version":3,"sources":["../../../../../../lib/contracts/registry.ts","../../../../../../lib/db/supabase.public.ts","../../../../../../lib/contracts/funnelManifest.ts","../../../../../../lib/utils/urlSecurity.ts","../../../../../../lib/funnels/loadFunnelVersion.ts","../../../../../../apps/rhythm-patient-ui/app/patient/funnel/%5Bslug%5D/intro/client.tsx/__nextjs-internal-proxy.mjs","../../../../../../apps/rhythm-patient-ui/app/patient/funnel/%5Bslug%5D/intro/page.tsx"],"sourcesContent":["/**\n * Contract Registry - Canonical Identifiers\n * \n * This file serves as the single source of truth for all critical string identifiers\n * used throughout the application. All new identifiers MUST be added here to prevent\n * \"fantasy names\" and ensure consistency.\n * \n * **IMPORTANT**: This file is protected by CODEOWNERS. Any changes require review.\n * \n * Usage:\n * ```typescript\n * import { ASSESSMENT_STATUS, FUNNEL_SLUG, USER_ROLE } from '@/lib/contracts/registry'\n * \n * const status: AssessmentStatus = ASSESSMENT_STATUS.IN_PROGRESS\n * const funnel: FunnelSlug = FUNNEL_SLUG.STRESS_ASSESSMENT\n * ```\n */\n\n// ============================================================\n// Assessment Statuses\n// ============================================================\n\n/**\n * Valid statuses for assessments\n */\nexport const ASSESSMENT_STATUS = {\n  IN_PROGRESS: 'in_progress',\n  COMPLETED: 'completed',\n} as const\n\nexport type AssessmentStatus = typeof ASSESSMENT_STATUS[keyof typeof ASSESSMENT_STATUS]\n\n// ============================================================\n// Content Page Statuses\n// ============================================================\n\n/**\n * Valid statuses for content pages\n */\nexport const CONTENT_STATUS = {\n  DRAFT: 'draft',\n  PUBLISHED: 'published',\n  ARCHIVED: 'archived',\n} as const\n\nexport type ContentStatus = typeof CONTENT_STATUS[keyof typeof CONTENT_STATUS]\n\n// ============================================================\n// Pillar Keys (7-Pillar Model)\n// ============================================================\n\n/**\n * Valid pillar keys for funnel taxonomy (7-Pillar Wellness Model)\n */\nexport const PILLAR_KEY = {\n  NUTRITION: 'nutrition',\n  MOVEMENT: 'movement',\n  SLEEP: 'sleep',\n  MENTAL_HEALTH: 'mental-health',\n  SOCIAL: 'social',\n  MEANING: 'meaning',\n  PREVENTION: 'prevention',\n} as const\n\nexport type PillarKey = typeof PILLAR_KEY[keyof typeof PILLAR_KEY]\n\n// ============================================================\n// Funnel Slugs\n// ============================================================\n\n/**\n * Valid funnel slugs\n * The canonical slug is the primary identifier\n * Legacy aliases are maintained for backward compatibility\n */\nexport const FUNNEL_SLUG = {\n  STRESS_ASSESSMENT: 'stress-assessment',\n  CARDIOVASCULAR_AGE: 'cardiovascular-age',\n  SLEEP_QUALITY: 'sleep-quality',\n  HEART_HEALTH_NUTRITION: 'heart-health-nutrition',\n  // Legacy aliases - deprecated but maintained for compatibility\n  STRESS: 'stress',\n  STRESS_CHECK: 'stress-check',\n  STRESS_CHECK_V2: 'stress-check-v2',\n} as const\n\nexport type FunnelSlug = typeof FUNNEL_SLUG[keyof typeof FUNNEL_SLUG]\n\n/**\n * Maps legacy funnel slugs to their canonical equivalents\n * Uses lowercase keys for case-insensitive matching\n */\nexport const FUNNEL_SLUG_ALIASES: Record<string, string> = {\n  'stress': FUNNEL_SLUG.STRESS_ASSESSMENT,\n  'stress-check': FUNNEL_SLUG.STRESS_ASSESSMENT,\n  'stress-check-v2': FUNNEL_SLUG.STRESS_ASSESSMENT,\n}\n\n/**\n * Resolves a funnel slug to its canonical form\n * Normalizes input by trimming and converting to lowercase for deterministic matching\n * \n * @param slug - The funnel slug to resolve (case-insensitive, whitespace trimmed)\n * @returns The canonical slug or the normalized input if no mapping exists\n */\nexport function getCanonicalFunnelSlug(slug: string): string {\n  const normalized = slug.toLowerCase().trim()\n  return FUNNEL_SLUG_ALIASES[normalized] || normalized\n}\n\n/**\n * Checks if a funnel slug is known in the registry\n * A funnel is \"known\" if it exists in FUNNEL_SLUG values (canonical or legacy)\n * \n * @param slug - The funnel slug to check (case-insensitive, whitespace trimmed)\n * @returns true if the funnel slug is registered, false otherwise\n */\nexport function isKnownFunnelSlug(slug: string): boolean {\n  const canonical = getCanonicalFunnelSlug(slug)\n  const allSlugs = Object.values(FUNNEL_SLUG)\n  return allSlugs.includes(canonical as FunnelSlug)\n}\n\n// ============================================================\n// Node/Step Types\n// ============================================================\n\n/**\n * Valid node/step types for funnel steps\n * These correspond to the 'type' field in the funnel_steps table\n */\nexport const NODE_TYPE = {\n  QUESTION_STEP: 'question_step',\n  FORM: 'form',\n  INFO_STEP: 'info_step',\n  INFO: 'info',\n  CONTENT_PAGE: 'content_page',\n  SUMMARY: 'summary',\n  OTHER: 'other',\n} as const\n\nexport type NodeType = typeof NODE_TYPE[keyof typeof NODE_TYPE]\n\n// ============================================================\n// User Roles\n// ============================================================\n\n/**\n * Valid user roles\n * These are stored in auth.users.raw_app_meta_data.role\n */\nexport const USER_ROLE = {\n  PATIENT: 'patient',\n  CLINICIAN: 'clinician',\n  ADMIN: 'admin',\n  NURSE: 'nurse',\n} as const\n\nexport type UserRole = typeof USER_ROLE[keyof typeof USER_ROLE]\n\n// ============================================================\n// Question Types\n// ============================================================\n\n/**\n * Valid question types\n * These correspond to the 'question_type' field in the questions table\n */\nexport const QUESTION_TYPE = {\n  RADIO: 'radio',\n  CHECKBOX: 'checkbox',\n  TEXT: 'text',\n  TEXTAREA: 'textarea',\n  NUMBER: 'number',\n  SCALE: 'scale',\n  SLIDER: 'slider',\n} as const\n\nexport type QuestionType = typeof QUESTION_TYPE[keyof typeof QUESTION_TYPE]\n\n// ============================================================\n// Patient Demographics\n// ============================================================\n\n/**\n * Valid sex/gender options for patient profiles\n * These correspond to the 'sex' field in the patient_profiles table\n */\nexport const PATIENT_SEX = {\n  MALE: 'male',\n  FEMALE: 'female',\n  OTHER: 'other',\n  PREFER_NOT_TO_SAY: 'prefer_not_to_say',\n} as const\n\nexport type PatientSex = typeof PATIENT_SEX[keyof typeof PATIENT_SEX]\n\n// ============================================================\n// Feature Flag Names\n// ============================================================\n\n/**\n * Valid feature flag names (without NEXT_PUBLIC_FEATURE_ prefix)\n */\nexport const FEATURE_FLAG = {\n  AMY_ENABLED: 'AMY_ENABLED',\n  CLINICIAN_DASHBOARD_ENABLED: 'CLINICIAN_DASHBOARD_ENABLED',\n  CHARTS_ENABLED: 'CHARTS_ENABLED',\n} as const\n\nexport type FeatureFlag = typeof FEATURE_FLAG[keyof typeof FEATURE_FLAG]\n\n// ============================================================\n// Helper Functions\n// ============================================================\n\n/**\n * Type guard to check if a value is a valid assessment status\n */\nexport function isValidAssessmentStatus(value: unknown): value is AssessmentStatus {\n  return typeof value === 'string' && Object.values(ASSESSMENT_STATUS).includes(value as AssessmentStatus)\n}\n\n/**\n * Type guard to check if a value is a valid content status\n */\nexport function isValidContentStatus(value: unknown): value is ContentStatus {\n  return typeof value === 'string' && Object.values(CONTENT_STATUS).includes(value as ContentStatus)\n}\n\n/**\n * Type guard to check if a value is a valid user role\n */\nexport function isValidUserRole(value: unknown): value is UserRole {\n  return typeof value === 'string' && Object.values(USER_ROLE).includes(value as UserRole)\n}\n\n/**\n * Type guard to check if a value is a valid node type\n */\nexport function isValidNodeType(value: unknown): value is NodeType {\n  return typeof value === 'string' && Object.values(NODE_TYPE).includes(value as NodeType)\n}\n\n/**\n * Type guard to check if a value is a valid pillar key\n */\nexport function isValidPillarKey(value: unknown): value is PillarKey {\n  return typeof value === 'string' && Object.values(PILLAR_KEY).includes(value as PillarKey)\n}\n\n/**\n * Type guard to check if a value is a valid patient sex option\n */\nexport function isValidPatientSex(value: unknown): value is PatientSex {\n  return typeof value === 'string' && Object.values(PATIENT_SEX).includes(value as PatientSex)\n}\n\n// ============================================================\n// Audit Log Entity Types\n// ============================================================\n\n/**\n * Valid entity types for audit logging\n * These correspond to the 'entity_type' field in the audit_log table\n */\nexport const AUDIT_ENTITY_TYPE = {\n  ASSESSMENT: 'assessment',\n  REPORT: 'report',\n  TASK: 'task',\n  FUNNEL_VERSION: 'funnel_version',\n  FUNNEL_CATALOG: 'funnel_catalog',\n  CONFIG: 'config',\n  CONSENT: 'consent',\n  ORGANIZATION: 'organization',\n  USER_ORG_MEMBERSHIP: 'user_org_membership',\n  CLINICIAN_ASSIGNMENT: 'clinician_assignment',\n  DOCUMENT: 'document', // V05-I04.3: Document confirmation tracking\n  PROCESSING_JOB: 'processing_job', // V05-I05.1: Processing job orchestration\n  REVIEW_RECORD: 'review_record', // V05-I05.7: Medical review records\n  PRE_SCREENING_CALL: 'pre_screening_call', // V05-I08.2: Pre-screening call records\n  DEVICE_SHIPMENT: 'device_shipment', // V05-I08.3: Shipment tracking\n  SUPPORT_CASE: 'support_case', // V05-I08.4: Support case documentation\n  ACCOUNT: 'account', // V05-I10.2: Account lifecycle (deletion/retention)\n} as const\n\nexport type AuditEntityType = typeof AUDIT_ENTITY_TYPE[keyof typeof AUDIT_ENTITY_TYPE]\n\n// ============================================================\n// Audit Log Actions\n// ============================================================\n\n/**\n * Valid actions for audit logging\n * These correspond to the 'action' field in the audit_log table\n */\nexport const AUDIT_ACTION = {\n  CREATE: 'create',\n  UPDATE: 'update',\n  DELETE: 'delete',\n  APPROVE: 'approve',\n  REJECT: 'reject',\n  REQUEST_CHANGES: 'request_changes', // V05-I05.7: Review workflow\n  GENERATE: 'generate',\n  FLAG: 'flag',\n  ASSIGN: 'assign',\n  ACTIVATE: 'activate',\n  DEACTIVATE: 'deactivate',\n  ROLLOUT: 'rollout',\n  COMPLETE: 'complete',\n  ESCALATE: 'escalate', // V05-I08.4: Support case escalation\n  DELETION_REQUEST: 'deletion_request', // V05-I10.2: User requested account deletion\n  DELETION_CANCEL: 'deletion_cancel', // V05-I10.2: User cancelled deletion request\n  DELETION_EXECUTE: 'deletion_execute', // V05-I10.2: System executed account deletion\n  ANONYMIZE: 'anonymize', // V05-I10.2: Records anonymized instead of deleted\n} as const\n\nexport type AuditAction = typeof AUDIT_ACTION[keyof typeof AUDIT_ACTION]\n\n// ============================================================\n// Audit Log Sources\n// ============================================================\n\n/**\n * Valid sources for audit logging\n * These correspond to the 'source' field in the audit_log table\n */\nexport const AUDIT_SOURCE = {\n  API: 'api',\n  JOB: 'job',\n  ADMIN_UI: 'admin-ui',\n  SYSTEM: 'system',\n} as const\n\nexport type AuditSource = typeof AUDIT_SOURCE[keyof typeof AUDIT_SOURCE]\n\n// ============================================================\n// Audit Type Guards\n// ============================================================\n\n/**\n * Type guard to check if a value is a valid audit entity type\n */\nexport function isValidAuditEntityType(value: unknown): value is AuditEntityType {\n  return typeof value === 'string' && Object.values(AUDIT_ENTITY_TYPE).includes(value as AuditEntityType)\n}\n\n/**\n * Type guard to check if a value is a valid audit action\n */\nexport function isValidAuditAction(value: unknown): value is AuditAction {\n  return typeof value === 'string' && Object.values(AUDIT_ACTION).includes(value as AuditAction)\n}\n\n/**\n * Type guard to check if a value is a valid audit source\n */\nexport function isValidAuditSource(value: unknown): value is AuditSource {\n  return typeof value === 'string' && Object.values(AUDIT_SOURCE).includes(value as AuditSource)\n}\n\n// ============================================================\n// Program Tier Levels (TV05_01D)\n// ============================================================\n\n/**\n * Valid program tier levels based on Thomas' journey model\n * These map the 3-tier patient journey to platform capabilities\n */\nexport const PROGRAM_TIER = {\n  /**\n   * Tier 1 (Essential): Basic stress/resilience assessment\n   * Focus: Initial assessment, baseline data collection\n   */\n  TIER_1_ESSENTIAL: 'tier-1-essential',\n  \n  /**\n   * Tier 2.5 (Enhanced): Extended monitoring with nurse touchpoints\n   * Focus: Regular check-ins, progress tracking\n   */\n  TIER_2_5_ENHANCED: 'tier-2-5-enhanced',\n  \n  /**\n   * Tier 2 (Comprehensive): Full program with intensive support\n   * Focus: Comprehensive care, multiple pillars, frequent touchpoints\n   */\n  TIER_2_COMPREHENSIVE: 'tier-2-comprehensive',\n} as const\n\nexport type ProgramTier = typeof PROGRAM_TIER[keyof typeof PROGRAM_TIER]\n\n/**\n * Type guard to check if a value is a valid program tier\n */\nexport function isValidProgramTier(value: unknown): value is ProgramTier {\n  return typeof value === 'string' && Object.values(PROGRAM_TIER).includes(value as ProgramTier)\n}\n\n// ============================================================\n// Document Extraction Versions (V05-I04.2)\n// ============================================================\n\n/**\n * Valid extractor versions for AI document extraction\n * Format: vMAJOR.MINOR.PATCH\n * Update when extraction logic or prompts change\n */\nexport const EXTRACTOR_VERSION = {\n  /**\n   * v1.0.0: Initial extraction pipeline\n   * - Basic lab value extraction\n   * - Medication list extraction\n   * - Confidence scoring\n   */\n  V1_0_0: 'v1.0.0',\n} as const\n\nexport type ExtractorVersion = typeof EXTRACTOR_VERSION[keyof typeof EXTRACTOR_VERSION]\n\n/**\n * Current extractor version (latest)\n */\nexport const CURRENT_EXTRACTOR_VERSION = EXTRACTOR_VERSION.V1_0_0\n\n/**\n * Type guard to check if a value is a valid extractor version\n */\nexport function isValidExtractorVersion(value: unknown): value is ExtractorVersion {\n  return typeof value === 'string' && Object.values(EXTRACTOR_VERSION).includes(value as ExtractorVersion)\n}\n\n// ============================================================\n// Processing Stages & Status (V05-I05.1)\n// ============================================================\n\n/**\n * Valid processing stages for job orchestrator\n * Jobs progress deterministically through these stages\n */\nexport const PROCESSING_STAGE = {\n  PENDING: 'pending',\n  RISK: 'risk',\n  RANKING: 'ranking',\n  CONTENT: 'content',\n  VALIDATION: 'validation',\n  REVIEW: 'review',\n  PDF: 'pdf',\n  DELIVERY: 'delivery',\n  COMPLETED: 'completed',\n  FAILED: 'failed',\n} as const\n\nexport type ProcessingStage = typeof PROCESSING_STAGE[keyof typeof PROCESSING_STAGE]\n\n/**\n * Valid processing statuses for job orchestrator\n */\nexport const PROCESSING_STATUS = {\n  QUEUED: 'queued',\n  IN_PROGRESS: 'in_progress',\n  COMPLETED: 'completed',\n  FAILED: 'failed',\n} as const\n\nexport type ProcessingStatus = typeof PROCESSING_STATUS[keyof typeof PROCESSING_STATUS]\n\n/**\n * Type guard to check if a value is a valid processing stage\n */\nexport function isValidProcessingStage(value: unknown): value is ProcessingStage {\n  return typeof value === 'string' && Object.values(PROCESSING_STAGE).includes(value as ProcessingStage)\n}\n\n/**\n * Type guard to check if a value is a valid processing status\n */\nexport function isValidProcessingStatus(value: unknown): value is ProcessingStatus {\n  return typeof value === 'string' && Object.values(PROCESSING_STATUS).includes(value as ProcessingStatus)\n}\n","/**\n * Public Supabase Client (Browser-Safe)\n * \n * This client is safe for use in browser bundles.\n * - Uses anon key only (no secrets)\n * - RLS policies are ACTIVE\n * - Suitable for client components and public data\n * \n * @module lib/db/supabase.public\n */\n\nimport { createClient } from '@supabase/supabase-js'\nimport { env } from '@/lib/env'\nimport type { Database } from '@/lib/types/supabase'\n\n/**\n * Creates a public Supabase client for browser use\n * \n * This client:\n * - Uses NEXT_PUBLIC_SUPABASE_ANON_KEY (safe for client bundles)\n * - Enforces RLS policies\n * - Should be used sparingly in favor of server-side data fetching\n * \n * @returns Supabase client instance\n * @throws Error if Supabase URL or anon key is not configured\n * \n * @example\n * ```typescript\n * import { createPublicClient } from '@/lib/db/supabase.public'\n * \n * const supabase = createPublicClient()\n * const { data } = await supabase.from('public_table').select('*')\n * ```\n */\nexport function createPublicClient() {\n  const url = env.NEXT_PUBLIC_SUPABASE_URL\n  const anonKey = env.NEXT_PUBLIC_SUPABASE_ANON_KEY\n\n  if (!url || !anonKey) {\n    throw new Error('Missing env: NEXT_PUBLIC_SUPABASE_URL, NEXT_PUBLIC_SUPABASE_ANON_KEY')\n  }\n\n  return createClient<Database>(url, anonKey, {\n    auth: {\n      persistSession: true,\n      autoRefreshToken: true,\n      detectSessionInUrl: true,\n    },\n  })\n}\n\n/**\n * Singleton public client instance (lazy-initialized)\n * \n * Use this for client-side operations where you don't need a fresh instance.\n * For most use cases, prefer server-side data fetching with createServerSupabaseClient.\n * \n * Lazy initialization ensures tests can mock before client creation.\n */\nlet _supabasePublic: ReturnType<typeof createPublicClient> | null = null\n\nexport function getSupabasePublic() {\n  if (!_supabasePublic) {\n    _supabasePublic = createPublicClient()\n  }\n  return _supabasePublic\n}\n\n/**\n * @deprecated Use getSupabasePublic() instead for lazy initialization\n * This is kept for backward compatibility but will be removed in future versions\n */\nexport const supabasePublic = new Proxy({} as ReturnType<typeof createPublicClient>, {\n  get(target, prop) {\n    return getSupabasePublic()[prop as keyof ReturnType<typeof createPublicClient>]\n  }\n})\n","/**\n * Funnel Plugin Manifest Schemas (V05-I02.2)\n * \n * This file defines the versioned \"Plugin Manifest\" structure for funnels.\n * All funnel versions store their configuration in JSONB fields validated by these schemas.\n * \n * **NO MAGIC STRINGS**: All question types, section types, and step types come from registry.\n * \n * Structure:\n * - FunnelQuestionnaireConfigSchema: Steps, questions, validation logic\n * - FunnelContentManifestSchema: Content pages, sections, assets\n * - Algorithm bundle version: String pointer to algorithm version\n * - Prompt version: String for content/report generation\n */\n\nimport { z } from 'zod'\nimport { NODE_TYPE, QUESTION_TYPE, type NodeType, type QuestionType } from './registry'\nimport { isValidUrl } from '@/lib/utils/urlSecurity'\n\nfunction normalizeQuestionType(value: unknown): unknown {\n  if (typeof value !== 'string') return value\n\n  const normalized = value.toLowerCase().trim()\n  if (Object.values(QUESTION_TYPE).includes(normalized as QuestionType)) {\n    return normalized\n  }\n\n  // Compatibility layer for older/looser DB values.\n  // Keep this mapping narrow + deterministic so QuestionRenderer still receives only registry types.\n  const aliases: Record<string, QuestionType> = {\n    // single choice\n    'single_choice': QUESTION_TYPE.RADIO,\n    'single-choice': QUESTION_TYPE.RADIO,\n    'select_one': QUESTION_TYPE.RADIO,\n    'select-one': QUESTION_TYPE.RADIO,\n    'multiple_choice': QUESTION_TYPE.RADIO,\n\n    // multiple select\n    'multi_choice': QUESTION_TYPE.CHECKBOX,\n    'multi-choice': QUESTION_TYPE.CHECKBOX,\n    'select_many': QUESTION_TYPE.CHECKBOX,\n    'select-many': QUESTION_TYPE.CHECKBOX,\n    'multiple_select': QUESTION_TYPE.CHECKBOX,\n    'multiple-select': QUESTION_TYPE.CHECKBOX,\n\n    // text\n    'short_text': QUESTION_TYPE.TEXT,\n    'short-text': QUESTION_TYPE.TEXT,\n    'string': QUESTION_TYPE.TEXT,\n\n    // textarea\n    'long_text': QUESTION_TYPE.TEXTAREA,\n    'long-text': QUESTION_TYPE.TEXTAREA,\n    'paragraph': QUESTION_TYPE.TEXTAREA,\n\n    // number\n    'integer': QUESTION_TYPE.NUMBER,\n    'float': QUESTION_TYPE.NUMBER,\n    'decimal': QUESTION_TYPE.NUMBER,\n\n    // scale/rating\n    'likert': QUESTION_TYPE.SCALE,\n    'likert_scale': QUESTION_TYPE.SCALE,\n    'likert-scale': QUESTION_TYPE.SCALE,\n    'rating': QUESTION_TYPE.SCALE,\n\n    // slider/range\n    'range': QUESTION_TYPE.SLIDER,\n  }\n\n  return aliases[normalized] ?? normalized\n}\n\n// IMPORTANT: keep this optional at the *object key* level.\n// Using `.transform()` directly can turn it into a required key with `string | undefined`.\nconst nullableString = z\n  .preprocess((value) => (value === null ? undefined : value), z.string().optional())\n  .optional()\n\n// ============================================================\n// Questionnaire Config Schema\n// ============================================================\n\n/**\n * V05-I06.4 Security: Safe URL validator for Zod schemas\n * Rejects javascript:, data:, vbscript:, file: and other dangerous protocols\n */\nconst safeUrlValidator = z.string().refine(\n  (url) => {\n    // Empty/undefined is OK for optional fields\n    if (!url || url.trim() === '') return true\n    return isValidUrl(url, false)\n  },\n  {\n    message: 'URL must use http:, https:, mailto:, tel:, or be a relative path. Dangerous protocols (javascript:, data:, vbscript:, file:) are not allowed.',\n  }\n)\n\n/**\n * Validation rule for question\n */\nexport const QuestionValidationSchema = z.object({\n  required: z.boolean().optional(),\n  min: z.number().optional(),\n  max: z.number().optional(),\n  pattern: z.string().optional(),\n  message: z.string().optional(),\n})\n\nexport type QuestionValidation = z.infer<typeof QuestionValidationSchema>\n\n/**\n * Option for radio/checkbox questions\n */\nexport const QuestionOptionSchema = z.object({\n  value: z.string(),\n  label: z.string(),\n  helpText: nullableString,\n})\n\nexport type QuestionOption = z.infer<typeof QuestionOptionSchema>\n\n/**\n * Individual question in questionnaire\n */\nexport const QuestionConfigSchema = z.object({\n  id: z.string(),\n  key: z.string(),\n  type: z.preprocess(\n    normalizeQuestionType,\n    z.enum([\n      QUESTION_TYPE.RADIO,\n      QUESTION_TYPE.CHECKBOX,\n      QUESTION_TYPE.TEXT,\n      QUESTION_TYPE.TEXTAREA,\n      QUESTION_TYPE.NUMBER,\n      QUESTION_TYPE.SCALE,\n      QUESTION_TYPE.SLIDER,\n    ] as [QuestionType, ...QuestionType[]]),\n  ),\n  label: z.string(),\n  helpText: nullableString,\n  required: z.boolean().default(false),\n  options: z.array(QuestionOptionSchema).optional(),\n  validation: QuestionValidationSchema.optional(),\n  minValue: z.number().optional(),\n  maxValue: z.number().optional(),\n})\n\nexport type QuestionConfig = z.infer<typeof QuestionConfigSchema>\n\n/**\n * Conditional logic for step/question visibility\n */\nexport const ConditionalLogicSchema = z.object({\n  type: z.enum(['show', 'hide', 'skip']),\n  conditions: z.array(\n    z.object({\n      questionId: z.string(),\n      operator: z.enum(['eq', 'neq', 'gt', 'gte', 'lt', 'lte', 'in', 'notIn']),\n      value: z.union([z.string(), z.number(), z.boolean(), z.array(z.string())]),\n    }),\n  ),\n  logic: z.enum(['and', 'or']).default('and'),\n})\n\nexport type ConditionalLogic = z.infer<typeof ConditionalLogicSchema>\n\n/**\n * Step in questionnaire flow\n */\nexport const QuestionnaireStepSchema = z.object({\n  id: z.string(),\n  title: z.string(),\n  description: z.string().optional(),\n  questions: z.array(QuestionConfigSchema),\n  conditionalLogic: ConditionalLogicSchema.optional(),\n})\n\nexport type QuestionnaireStep = z.infer<typeof QuestionnaireStepSchema>\n\n/**\n * Complete questionnaire configuration\n */\nexport const FunnelQuestionnaireConfigSchema = z.object({\n  version: z.string().default('1.0'),\n  steps: z.array(QuestionnaireStepSchema),\n  conditionalLogic: z.array(ConditionalLogicSchema).optional(),\n  metadata: z.record(z.string(), z.any()).optional(),\n})\n\nexport type FunnelQuestionnaireConfig = z.infer<typeof FunnelQuestionnaireConfigSchema>\n\n// ============================================================\n// Content Manifest Schema\n// ============================================================\n\n/**\n * Section types for content pages\n * These are the allowed types for sections within content pages\n */\nexport const SECTION_TYPE = {\n  HERO: 'hero',\n  TEXT: 'text',\n  IMAGE: 'image',\n  VIDEO: 'video',\n  MARKDOWN: 'markdown',\n  CTA: 'cta',\n  DIVIDER: 'divider',\n} as const\n\nexport type SectionType = typeof SECTION_TYPE[keyof typeof SECTION_TYPE]\n\n/**\n * Content section within a page\n * \n * V05-I06.2 Hardening: Added strict bounds and validation\n * V05-I06.4 Security: Added URL validation for content fields\n * - key: max 200 chars (prevent DoS)\n * - contentRef: max 2048 chars (URL/path length limit)\n * - orderIndex: non-negative integer (deterministic sorting)\n * - content.url, content.href: validated against dangerous protocols\n * - No unknown keys allowed (strict mode via .strict())\n */\nexport const ContentSectionSchema = z\n  .object({\n    key: z.string().min(1).max(200),\n    type: z.enum([\n      SECTION_TYPE.HERO,\n      SECTION_TYPE.TEXT,\n      SECTION_TYPE.IMAGE,\n      SECTION_TYPE.VIDEO,\n      SECTION_TYPE.MARKDOWN,\n      SECTION_TYPE.CTA,\n      SECTION_TYPE.DIVIDER,\n    ] as [SectionType, ...SectionType[]]),\n    contentRef: z.string().max(2048).optional(),\n    content: z.record(z.string(), z.any()).optional(),\n    orderIndex: z.number().int().nonnegative().optional(),\n  })\n  .strict()\n  .refine(\n    (section) => {\n      // Validate URLs in content object for security\n      if (!section.content) return true\n      \n      // Check href field (CTA blocks)\n      if ('href' in section.content && typeof section.content.href === 'string') {\n        if (!isValidUrl(section.content.href, false)) {\n          return false\n        }\n      }\n      \n      // Check url field (Image, Video blocks)\n      if ('url' in section.content && typeof section.content.url === 'string') {\n        if (!isValidUrl(section.content.url, false)) {\n          return false\n        }\n      }\n      \n      // Check backgroundImage field (Hero blocks)\n      if ('backgroundImage' in section.content && typeof section.content.backgroundImage === 'string') {\n        if (section.content.backgroundImage && !isValidUrl(section.content.backgroundImage, false)) {\n          return false\n        }\n      }\n      \n      return true\n    },\n    {\n      message: 'Content URLs must use safe protocols (http:, https:, mailto:, tel:, or relative paths). Dangerous protocols (javascript:, data:, vbscript:, file:) are not allowed.',\n    }\n  )\n\nexport type ContentSection = z.infer<typeof ContentSectionSchema>\n\n/**\n * Content page definition\n * \n * V05-I06.2 Hardening: Added strict bounds\n * - slug: max 200 chars, alphanumeric + hyphens\n * - title: max 500 chars\n * - description: max 2000 chars\n * - sections: max 100 sections per page\n * - No unknown keys allowed (strict mode)\n */\nexport const ContentPageSchema = z\n  .object({\n    slug: z\n      .string()\n      .min(1)\n      .max(200)\n      .regex(/^[a-z0-9-]+$/, 'Slug must be lowercase alphanumeric with hyphens'),\n    title: z.string().min(1).max(500),\n    description: z.string().max(2000).optional(),\n    sections: z.array(ContentSectionSchema).max(100),\n    metadata: z.record(z.string(), z.any()).optional(),\n  })\n  .strict()\n\nexport type ContentPage = z.infer<typeof ContentPageSchema>\n\n/**\n * Complete content manifest\n * \n * V05-I06.2 Hardening: Added strict bounds\n * - version: max 20 chars\n * - pages: max 50 pages per manifest\n * - assets: max 200 assets per manifest\n * - asset key: max 200 chars\n * - asset url: max 2048 chars\n * - No unknown keys allowed (strict mode)\n */\nexport const FunnelContentManifestSchema = z\n  .object({\n    version: z.string().max(20).default('1.0'),\n    pages: z.array(ContentPageSchema).max(50),\n    assets: z\n      .array(\n        z\n          .object({\n            key: z.string().min(1).max(200),\n            type: z.enum(['image', 'video', 'audio', 'document']),\n            url: safeUrlValidator.min(1).max(2048),\n            metadata: z.record(z.string(), z.any()).optional(),\n          })\n          .strict(),\n      )\n      .max(200)\n      .optional(),\n    metadata: z.record(z.string(), z.any()).optional(),\n  })\n  .strict()\n\nexport type FunnelContentManifest = z.infer<typeof FunnelContentManifestSchema>\n\n// ============================================================\n// Complete Plugin Manifest\n// ============================================================\n\n/**\n * Complete funnel plugin manifest\n * This represents all configuration data for a funnel version\n */\nexport const FunnelPluginManifestSchema = z.object({\n  questionnaire_config: FunnelQuestionnaireConfigSchema,\n  content_manifest: FunnelContentManifestSchema,\n  algorithm_bundle_version: z.string(),\n  prompt_version: z.string(),\n})\n\nexport type FunnelPluginManifest = z.infer<typeof FunnelPluginManifestSchema>\n\n// ============================================================\n// Helper Functions\n// ============================================================\n\n/**\n * Type guard to check if a value is a valid section type\n */\nexport function isValidSectionType(value: unknown): value is SectionType {\n  return typeof value === 'string' && Object.values(SECTION_TYPE).includes(value as SectionType)\n}\n\n/**\n * Validates and parses questionnaire config from JSONB\n * @throws ZodError if validation fails\n */\nexport function parseQuestionnaireConfig(\n  json: unknown,\n): FunnelQuestionnaireConfig {\n  return FunnelQuestionnaireConfigSchema.parse(json)\n}\n\n/**\n * Safely parses questionnaire config with error handling\n * @returns Parsed config or null if invalid\n */\nexport function safeParseQuestionnaireConfig(\n  json: unknown,\n): FunnelQuestionnaireConfig | null {\n  const result = FunnelQuestionnaireConfigSchema.safeParse(json)\n  return result.success ? result.data : null\n}\n\n/**\n * Validates and parses content manifest from JSONB\n * @throws ZodError if validation fails\n */\nexport function parseContentManifest(json: unknown): FunnelContentManifest {\n  return FunnelContentManifestSchema.parse(json)\n}\n\n/**\n * Safely parses content manifest with error handling\n * @returns Parsed manifest or null if invalid\n */\nexport function safeParseContentManifest(json: unknown): FunnelContentManifest | null {\n  const result = FunnelContentManifestSchema.safeParse(json)\n  return result.success ? result.data : null\n}\n\n/**\n * Validates and parses complete plugin manifest\n * @throws ZodError if validation fails\n */\nexport function parsePluginManifest(json: unknown): FunnelPluginManifest {\n  return FunnelPluginManifestSchema.parse(json)\n}\n\n/**\n * Safely parses complete plugin manifest with error handling\n * @returns Parsed manifest or null if invalid\n */\nexport function safeParsePluginManifest(json: unknown): FunnelPluginManifest | null {\n  const result = FunnelPluginManifestSchema.safeParse(json)\n  return result.success ? result.data : null\n}\n","/**\n * URL Security Validation (V05-I06.2 Hardening)\n * \n * Validates URLs to prevent XSS and other security issues\n * Denies javascript:, data:, vbscript:, and other dangerous protocols\n */\n\n/**\n * Allowed URL protocols for content blocks\n */\nconst ALLOWED_PROTOCOLS = ['http:', 'https:', 'mailto:', 'tel:']\n\n/**\n * Maximum URL length to prevent buffer overflow attacks\n */\nconst MAX_URL_LENGTH = 2048\n\n/**\n * Validates a URL for security\n * \n * Rejects:\n * - javascript: URLs (XSS)\n * - data: URLs (unless explicitly allowed)\n * - vbscript: URLs (XSS)\n * - file: URLs (local file access)\n * - Overly long URLs (DoS)\n * \n * @param url - URL to validate\n * @param allowDataUrls - Whether to allow data: URLs (default: false)\n * @returns true if URL is safe, false otherwise\n */\nexport function isValidUrl(url: string | undefined, allowDataUrls = false): boolean {\n  if (!url || typeof url !== 'string') {\n    return false\n  }\n\n  // Check length\n  if (url.length > MAX_URL_LENGTH) {\n    return false\n  }\n\n  // Trim and normalize\n  const trimmed = url.trim().toLowerCase()\n\n  // Empty after trim\n  if (trimmed.length === 0) {\n    return false\n  }\n\n  // Check for dangerous protocols (always forbidden)\n  const dangerousProtocols = ['javascript:', 'vbscript:', 'file:', 'about:']\n  \n  for (const protocol of dangerousProtocols) {\n    if (trimmed.startsWith(protocol)) {\n      return false\n    }\n  }\n\n  // Handle data: URLs separately\n  if (trimmed.startsWith('data:')) {\n    return allowDataUrls\n  }\n\n  // Relative URLs are OK (start with /, ./, ../)\n  if (trimmed.startsWith('/') || trimmed.startsWith('./') || trimmed.startsWith('../')) {\n    return true\n  }\n\n  // Check for allowed protocols\n  try {\n    const parsed = new URL(url)\n    return ALLOWED_PROTOCOLS.includes(parsed.protocol)\n  } catch {\n    // If URL parsing fails, allow relative URLs that don't look suspicious\n    // This handles cases like \"page.html\" or \"#anchor\"\n    return !trimmed.includes(':')\n  }\n}\n\n/**\n * Sanitizes a URL by returning it only if valid, otherwise returns fallback\n * \n * @param url - URL to sanitize\n * @param fallback - Fallback URL if invalid (default: '#')\n * @param allowDataUrls - Whether to allow data: URLs (default: false)\n * @returns Sanitized URL or fallback\n */\nexport function sanitizeUrl(\n  url: string | undefined,\n  fallback = '#',\n  allowDataUrls = false,\n): string {\n  return isValidUrl(url, allowDataUrls) ? url! : fallback\n}\n\n/**\n * Gets safe link props for external links\n * Adds rel=\"noopener noreferrer\" for external links\n * \n * @param href - Link href\n * @returns Object with href and optional rel/target\n */\nexport function getSafeLinkProps(href: string): {\n  href: string\n  rel?: string\n  target?: string\n} {\n  const sanitized = sanitizeUrl(href)\n\n  // Check if external link (starts with http:// or https://)\n  const isExternal =\n    sanitized.startsWith('http://') || sanitized.startsWith('https://')\n\n  if (isExternal) {\n    return {\n      href: sanitized,\n      rel: 'noopener noreferrer',\n      target: '_blank',\n    }\n  }\n\n  return { href: sanitized }\n}\n","/**\n * Funnel Version Loader (V05-I02.2)\n * \n * Server-only module for loading and validating funnel versions with their plugin manifests.\n * \n * **IMPORTANT**: This module uses Supabase server client and should ONLY be used in:\n * - Server Components\n * - API Routes\n * - Server Actions\n * \n * DO NOT import this in client components!\n */\n\nimport { createPublicClient } from '@/lib/db/supabase.public'\nimport type { SupabaseClient } from '@supabase/supabase-js'\nimport {\n  FunnelPluginManifestSchema,\n  FunnelQuestionnaireConfigSchema,\n  FunnelContentManifestSchema,\n  parseQuestionnaireConfig,\n  parseContentManifest,\n  type FunnelPluginManifest,\n  type FunnelQuestionnaireConfig,\n  type FunnelContentManifest,\n} from '@/lib/contracts/funnelManifest'\nimport { getCanonicalFunnelSlug } from '@/lib/contracts/registry'\n\n// ============================================================\n// Type Definitions\n// ============================================================\n\n/**\n * Raw funnel version data from database\n */\nexport type FunnelVersionRow = {\n  id: string\n  funnel_id: string\n  version: string\n  questionnaire_config: unknown\n  content_manifest: unknown\n  algorithm_bundle_version: string\n  prompt_version: string\n  is_default: boolean\n  rollout_percent: number\n  created_at: string\n  updated_at: string | null\n}\n\n/**\n * Loaded and validated funnel version with parsed manifest\n */\nexport type LoadedFunnelVersion = {\n  id: string\n  funnelId: string\n  version: string\n  manifest: FunnelPluginManifest\n  isDefault: boolean\n  rolloutPercent: number\n  createdAt: string\n  updatedAt: string | null\n}\n\n/**\n * Funnel catalog entry\n */\nexport type FunnelCatalogEntry = {\n  id: string\n  slug: string\n  title: string\n  pillarId: string | null\n  description: string | null\n  isActive: boolean\n  defaultVersionId: string | null\n}\n\n/**\n * Error types for funnel loading\n */\nexport class FunnelNotFoundError extends Error {\n  constructor(slug: string) {\n    super(`Funnel not found: ${slug}`)\n    this.name = 'FunnelNotFoundError'\n  }\n}\n\nexport class FunnelVersionNotFoundError extends Error {\n  constructor(funnelId: string, version?: string) {\n    super(\n      version\n        ? `Funnel version not found: ${funnelId}@${version}`\n        : `No default version found for funnel: ${funnelId}`,\n    )\n    this.name = 'FunnelVersionNotFoundError'\n  }\n}\n\nexport class ManifestValidationError extends Error {\n  constructor(message: string, public cause?: unknown) {\n    super(`Manifest validation failed: ${message}`)\n    this.name = 'ManifestValidationError'\n  }\n}\n\n// ============================================================\n// Supabase Client (Server-only)\n// ============================================================\n\n/**\n * Get Supabase server client\n * Uses environment variables for auth\n */\nfunction getSupabaseServerClient() {\n  return createPublicClient()\n}\n\nasync function resolvePatientActiveVersionId(\n  supabase: SupabaseClient<any>,\n  funnelId: string,\n): Promise<string | null> {\n  try {\n    const {\n      data: { user },\n    } = await supabase.auth.getUser()\n\n    if (!user) return null\n\n    const { data: patientProfile, error: patientProfileError } = await supabase\n      .from('patient_profiles')\n      .select('id')\n      .eq('user_id', user.id)\n      .single()\n\n    if (patientProfileError || !patientProfile) return null\n\n    const { data: patientFunnel } = await supabase\n      .from('patient_funnels')\n      .select('active_version_id')\n      .eq('patient_id', patientProfile.id)\n      .eq('funnel_id', funnelId)\n      .order('updated_at', { ascending: false })\n      .order('created_at', { ascending: false })\n      .limit(1)\n      .maybeSingle()\n\n    return patientFunnel?.active_version_id ?? null\n  } catch {\n    return null\n  }\n}\n\n// ============================================================\n// Core Loader Functions\n// ============================================================\n\n/**\n * Loads a funnel by slug (canonical resolution)\n * \n * @param slug - Funnel slug (can be legacy alias)\n * @returns Funnel catalog entry or null if not found\n */\nexport async function loadFunnelWithClient(\n  supabase: SupabaseClient<any>,\n  slug: string,\n): Promise<FunnelCatalogEntry | null> {\n  const canonicalSlug = getCanonicalFunnelSlug(slug)\n\n  const { data, error } = await supabase\n    .from('funnels_catalog')\n    .select('id, slug, title, pillar_id, description, is_active, default_version_id')\n    .eq('slug', canonicalSlug)\n    .single()\n\n  if (error || !data) {\n    return null\n  }\n\n  return {\n    id: data.id,\n    slug: data.slug,\n    title: data.title,\n    pillarId: data.pillar_id,\n    description: data.description,\n    isActive: data.is_active,\n    defaultVersionId: data.default_version_id,\n  }\n}\n\nexport async function loadFunnel(slug: string): Promise<FunnelCatalogEntry | null> {\n  const supabase = getSupabaseServerClient()\n  return loadFunnelWithClient(supabase, slug)\n}\n\n/**\n * Loads a specific funnel version by ID\n * \n * @param versionId - UUID of the funnel version\n * @returns Loaded and validated funnel version\n * @throws {FunnelVersionNotFoundError} If version not found\n * @throws {ManifestValidationError} If manifest validation fails\n */\nexport async function loadFunnelVersionById(\n  versionId: string,\n): Promise<LoadedFunnelVersion> {\n  const supabase = getSupabaseServerClient()\n\n  return loadFunnelVersionByIdWithClient(supabase, versionId)\n}\n\nexport async function loadFunnelVersionByIdWithClient(\n  supabase: SupabaseClient<any>,\n  versionId: string,\n): Promise<LoadedFunnelVersion> {\n\n  const { data, error } = await supabase\n    .from('funnel_versions')\n    .select('*')\n    .eq('id', versionId)\n    .single()\n\n  if (error || !data) {\n    throw new FunnelVersionNotFoundError(versionId)\n  }\n\n  return parseAndValidateFunnelVersion(data as FunnelVersionRow)\n}\n\n/**\n * Loads the default version for a funnel\n * \n * @param funnelId - UUID of the funnel\n * @returns Loaded and validated default funnel version\n * @throws {FunnelVersionNotFoundError} If no default version found\n * @throws {ManifestValidationError} If manifest validation fails\n */\nexport async function loadDefaultFunnelVersion(\n  funnelId: string,\n): Promise<LoadedFunnelVersion> {\n  const supabase = getSupabaseServerClient()\n\n  return loadDefaultFunnelVersionWithClient(supabase, funnelId)\n}\n\nexport async function loadDefaultFunnelVersionWithClient(\n  supabase: SupabaseClient<any>,\n  funnelId: string,\n): Promise<LoadedFunnelVersion> {\n  const { data: funnel, error: funnelError } = await supabase\n    .from('funnels_catalog')\n    .select('default_version_id')\n    .eq('id', funnelId)\n    .single()\n\n  if (funnelError || !funnel?.default_version_id) {\n    throw new FunnelVersionNotFoundError(funnelId)\n  }\n\n  return loadFunnelVersionByIdWithClient(supabase, funnel.default_version_id)\n}\n\n/**\n * Loads a specific version by funnel ID and version string\n * \n * @param funnelId - UUID of the funnel\n * @param version - Version string (e.g., '1.0.0')\n * @returns Loaded and validated funnel version\n * @throws {FunnelVersionNotFoundError} If version not found\n * @throws {ManifestValidationError} If manifest validation fails\n */\nexport async function loadFunnelVersionByVersion(\n  funnelId: string,\n  version: string,\n): Promise<LoadedFunnelVersion> {\n  const supabase = getSupabaseServerClient()\n\n  return loadFunnelVersionByVersionWithClient(supabase, funnelId, version)\n}\n\nexport async function loadFunnelVersionByVersionWithClient(\n  supabase: SupabaseClient<any>,\n  funnelId: string,\n  version: string,\n): Promise<LoadedFunnelVersion> {\n\n  const { data, error } = await supabase\n    .from('funnel_versions')\n    .select('*')\n    .eq('funnel_id', funnelId)\n    .eq('version', version)\n    .single()\n\n  if (error || !data) {\n    throw new FunnelVersionNotFoundError(funnelId, version)\n  }\n\n  return parseAndValidateFunnelVersion(data as FunnelVersionRow)\n}\n\n/**\n * High-level loader: Loads funnel and its default version by slug\n * \n * @param slug - Funnel slug (canonical or legacy alias)\n * @returns Loaded funnel version with manifest\n * @throws {FunnelNotFoundError} If funnel not found\n * @throws {FunnelVersionNotFoundError} If no default version found\n * @throws {ManifestValidationError} If manifest validation fails\n */\nexport async function loadFunnelVersion(slug: string): Promise<LoadedFunnelVersion> {\n  const supabase = getSupabaseServerClient()\n  return loadFunnelVersionWithClient(supabase, slug)\n}\n\nexport async function loadFunnelVersionWithClient(\n  supabase: SupabaseClient<any>,\n  slug: string,\n): Promise<LoadedFunnelVersion> {\n  const funnel = await loadFunnelWithClient(supabase, slug)\n\n  if (!funnel) {\n    throw new FunnelNotFoundError(slug)\n  }\n\n  const patientActiveVersionId = await resolvePatientActiveVersionId(supabase, funnel.id)\n  const effectiveVersionId = patientActiveVersionId ?? funnel.defaultVersionId\n\n  if (!effectiveVersionId) {\n    throw new FunnelVersionNotFoundError(funnel.id)\n  }\n\n  return loadFunnelVersionByIdWithClient(supabase, effectiveVersionId)\n}\n\n// ============================================================\n// Validation Helpers\n// ============================================================\n\n/**\n * Parses and validates a funnel version row from the database\n * \n * @param row - Raw funnel version data\n * @returns Validated funnel version with parsed manifest\n * @throws {ManifestValidationError} If validation fails\n */\nfunction parseAndValidateFunnelVersion(row: FunnelVersionRow): LoadedFunnelVersion {\n  try {\n    // Parse and validate questionnaire config\n    const questionnaireConfig = parseQuestionnaireConfig(row.questionnaire_config)\n\n    // Parse and validate content manifest\n    const contentManifest = parseContentManifest(row.content_manifest)\n\n    // Construct complete manifest\n    const manifest: FunnelPluginManifest = {\n      questionnaire_config: questionnaireConfig,\n      content_manifest: contentManifest,\n      algorithm_bundle_version: row.algorithm_bundle_version,\n      prompt_version: row.prompt_version,\n    }\n\n    // Final validation of complete manifest\n    FunnelPluginManifestSchema.parse(manifest)\n\n    return {\n      id: row.id,\n      funnelId: row.funnel_id,\n      version: row.version,\n      manifest,\n      isDefault: row.is_default,\n      rolloutPercent: row.rollout_percent,\n      createdAt: row.created_at,\n      updatedAt: row.updated_at,\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new ManifestValidationError(error.message, error)\n    }\n    throw new ManifestValidationError('Unknown validation error', error)\n  }\n}\n\n/**\n * Validates questionnaire config without loading from database\n * Useful for validation during creation/update operations\n * \n * @param config - Questionnaire config to validate\n * @returns Validated config\n * @throws {ManifestValidationError} If validation fails\n */\nexport function validateQuestionnaireConfig(\n  config: unknown,\n): FunnelQuestionnaireConfig {\n  try {\n    return FunnelQuestionnaireConfigSchema.parse(config)\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new ManifestValidationError(\n        `Questionnaire config validation failed: ${error.message}`,\n        error,\n      )\n    }\n    throw new ManifestValidationError('Unknown questionnaire config validation error', error)\n  }\n}\n\n/**\n * Validates content manifest without loading from database\n * Useful for validation during creation/update operations\n * \n * @param manifest - Content manifest to validate\n * @returns Validated manifest\n * @throws {ManifestValidationError} If validation fails\n */\nexport function validateContentManifest(manifest: unknown): FunnelContentManifest {\n  try {\n    return FunnelContentManifestSchema.parse(manifest)\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new ManifestValidationError(\n        `Content manifest validation failed: ${error.message}`,\n        error,\n      )\n    }\n    throw new ManifestValidationError('Unknown content manifest validation error', error)\n  }\n}\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/apps/rhythm-patient-ui/app/patient/funnel/[slug]/intro/client.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/apps/rhythm-patient-ui/app/patient/funnel/[slug]/intro/client.tsx\",\n    \"default\",\n);\n","import { redirect, notFound } from 'next/navigation'\nimport { createServerSupabaseClient } from '@/lib/db/supabase.server'\nimport { enforceDashboardFirst } from '@/lib/utils/dashboardFirstPolicy'\nimport IntroPageClient from './client'\nimport {\n  loadFunnelVersionWithClient,\n  FunnelNotFoundError,\n  FunnelVersionNotFoundError,\n  ManifestValidationError,\n} from '@/lib/funnels/loadFunnelVersion'\nimport type {\n  ContentPage as ManifestContentPage,\n  FunnelContentManifest,\n  QuestionnaireStep,\n} from '@/lib/contracts/funnelManifest'\n\ntype ManifestData = {\n  version: string\n  funnelId: string\n  algorithmVersion: string\n  promptVersion: string\n  steps: QuestionnaireStep[]\n  contentPages: ManifestContentPage[]\n  contentManifest: FunnelContentManifest\n}\n\ntype PageProps = {\n  params: Promise<{ slug: string }>\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}\n\nexport default async function IntroPage({ params }: PageProps) {\n  const { slug } = await params\n\n  // Create Supabase server client (canonical)\n  const supabase = await createServerSupabaseClient()\n\n  // E6.5.1 AC3: Check authentication FIRST (401-first, no DB calls before auth)\n  const {\n    data: { user },\n  } = await supabase.auth.getUser()\n\n  if (!user) {\n    redirect('/')\n  }\n\n  // E6.5.1 AC2: Enforce dashboard-first policy\n  const pathname = `/patient/funnel/${slug}/intro`\n  const redirectUrl = await enforceDashboardFirst(pathname)\n  \n  if (redirectUrl) {\n    redirect(redirectUrl)\n  }\n\n  // Load funnel version manifest (server-side)\n  // V05-I06.5: Fail-closed behavior for missing/invalid manifests\n  let manifestData: ManifestData | null = null\n  let manifestError: string | null = null\n\n  try {\n    const funnelVersion = await loadFunnelVersionWithClient(supabase, slug)\n\n    manifestData = {\n      version: funnelVersion.version,\n      funnelId: funnelVersion.funnelId,\n      algorithmVersion: funnelVersion.manifest.algorithm_bundle_version,\n      promptVersion: funnelVersion.manifest.prompt_version,\n      steps: funnelVersion.manifest.questionnaire_config.steps,\n      contentPages: funnelVersion.manifest.content_manifest.pages,\n      contentManifest: funnelVersion.manifest.content_manifest,\n    }\n  } catch (error) {\n    if (error instanceof FunnelNotFoundError) {\n      // 404: Funnel not found\n      console.error(`[INTRO_PAGE] Funnel not found: ${slug}`)\n      notFound()\n    } else if (error instanceof FunnelVersionNotFoundError) {\n      // No effective version resolved (empty-state)\n      console.error(`[INTRO_PAGE] No effective funnel version resolved for ${slug} (falling back to legacy intro)`)\n      manifestData = null\n      manifestError = null\n    } else if (error instanceof ManifestValidationError) {\n      // Manifest invalid/missing: allow legacy intro fallback.\n      // Intro content is optional and should not hard-block access.\n      console.error(`[INTRO_PAGE] Manifest validation failed for ${slug} (falling back to legacy intro):`, error.message)\n      manifestData = null\n      manifestError = null\n    } else {\n      // 500: Unexpected error - re-throw to trigger error boundary\n      console.error(`[INTRO_PAGE] Unexpected error loading funnel ${slug}:`, error)\n      throw error\n    }\n  }\n\n  return <IntroPageClient funnelSlug={slug} manifestData={manifestData} manifestError={manifestError} />\n}\n"],"names":[],"mappings":"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","ignoreList":[5]}
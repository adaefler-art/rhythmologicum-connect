name: Apply Supabase migrations

on:
  push:
    branches: [ main ]
    paths:
      - 'supabase/migrations/**'
  workflow_dispatch:
    inputs:
      include_all:
        description: 'Force apply migrations that would be inserted before last remote migration (passes --include-all to supabase db push). Use with care.'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      baseline_repair:
        description: 'Mark known baseline migrations as applied on remote (uses supabase migration repair; requires SUPABASE_DB_PASSWORD secret).'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      repair_versions:
        description: 'Comma/space-separated migration versions to mark as applied in remote history (e.g. 20251207074557). Requires SUPABASE_DB_URL secret.'
        required: false
        default: ''
        type: string

permissions:
  contents: write  # Required for auto-commit of regenerated types

concurrency:
  group: supabase-migrations-${{ github.ref }}
  cancel-in-progress: false  # Don't cancel; wait for completion to avoid partial migration state

jobs:
  apply-migrations:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Exit if triggered by bot
        if: "github.actor == 'github-actions[bot]'"
        run: |
          echo "Run triggered by github-actions[bot]; exiting to avoid loop."
          exit 0

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Validate required secrets
        run: |
          if [ -z "${{ secrets.SUPABASE_ACCESS_TOKEN }}" ]; then
            echo "ERROR: SUPABASE_ACCESS_TOKEN secret is not set"
            echo "Please add this secret in GitHub repository settings"
            exit 1
          fi

          # Basic format check to prevent using anon keys / JWTs by accident.
          # Supabase Personal Access Tokens typically look like: sbp_...
          TOKEN="${{ secrets.SUPABASE_ACCESS_TOKEN }}"
          if ! echo "$TOKEN" | grep -Eq '^sbp_[A-Za-z0-9]+'; then
            echo "ERROR: SUPABASE_ACCESS_TOKEN has an invalid format."
            echo "Expected a Supabase Personal Access Token that starts with 'sbp_...'"
            echo "Common mistake: using NEXT_PUBLIC_SUPABASE_ANON_KEY (often starts with 'eyJ' or 'sb_publishable_...')"
            echo "Fix: Supabase Dashboard (account) -> Access Tokens -> create token -> set as GitHub secret SUPABASE_ACCESS_TOKEN"
            exit 1
          fi

          PROJECT_REF="${{ secrets.SUPABASE_PROJECT_ID }}"
          if [ -z "$PROJECT_REF" ]; then
            PROJECT_REF="${{ secrets.SUPABASE_PROJECT_REF }}"
          fi
          if [ -z "$PROJECT_REF" ]; then
            echo "ERROR: Missing Supabase project ref secret"
            echo "Please set either SUPABASE_PROJECT_ID or SUPABASE_PROJECT_REF"
            echo "Hint: The project ref is the value in the Supabase Dashboard URL:"
            echo "  https://supabase.com/dashboard/project/<project-ref>"
            exit 1
          fi
          echo "‚úì Required secrets are configured"

      - name: Link Supabase project
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          SUPABASE_PROJECT_REF: ${{ secrets.SUPABASE_PROJECT_ID || secrets.SUPABASE_PROJECT_REF }}
        run: |
          supabase link --project-ref "$SUPABASE_PROJECT_REF"

      - name: Show migration status (local vs remote)
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "Local + remote migration status:"
          supabase migration list --linked || supabase migration list || true

      - name: Optional baseline repair (remote history)
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.baseline_repair == 'true' }}
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          SUPABASE_DB_URL: ${{ secrets.SUPABASE_DB_URL }}
        run: |
          if [ -z "$SUPABASE_DB_URL" ]; then
            echo "ERROR: SUPABASE_DB_URL secret is not set"
            echo "This step needs a Postgres connection string to update supabase_migrations.schema_migrations."
            echo "Tip: You can copy it from Supabase Dashboard > Project Settings > Database > Connection string."
            exit 1
          fi

          echo "Installing psql client..."
          sudo apt-get update -y
          sudo apt-get install -y postgresql-client

          echo "Repairing remote migration history for legacy baseline migrations (mark as applied, without executing SQL)..."

          psql "$SUPABASE_DB_URL" -v ON_ERROR_STOP=1 <<'SQL'
          INSERT INTO supabase_migrations.schema_migrations(version, name)
          VALUES
            ('01', '01_create_funnel_tables'),
            ('02', '02_add_funnel_id_to_assessments'),
            ('03', '03_create_content_pages'),
            ('20241203110000', '20241203110000_init_patient_profiles_and_assessments')
          ON CONFLICT (version) DO NOTHING;
          SQL

          echo "Baseline repair complete. Current remote migration list:"
          supabase migration list --linked || true

      - name: Optional repair additional migration versions (remote history)
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.repair_versions != '' }}
        env:
          SUPABASE_DB_URL: ${{ secrets.SUPABASE_DB_URL }}
        run: |
          if [ -z "$SUPABASE_DB_URL" ]; then
            echo "ERROR: SUPABASE_DB_URL secret is not set"
            exit 1
          fi

          echo "Installing psql client..."
          sudo apt-get update -y
          sudo apt-get install -y postgresql-client

          echo "Repairing remote migration history for: ${{ inputs.repair_versions }}"
          REPAIR_INPUT="${{ inputs.repair_versions }}"

          # Split on commas and whitespace
          IFS=', ' read -r -a VERSIONS <<< "$REPAIR_INPUT"
          for V in "${VERSIONS[@]}"; do
            if [ -z "$V" ]; then
              continue
            fi
            if ! echo "$V" | grep -Eq '^[0-9]+$'; then
              echo "ERROR: Invalid migration version '$V' (digits only)"
              exit 1
            fi
            echo "Marking migration version as applied: $V"
            psql "$SUPABASE_DB_URL" -v ON_ERROR_STOP=1 -c "INSERT INTO supabase_migrations.schema_migrations(version, name) VALUES ('$V', '$V') ON CONFLICT (version) DO NOTHING;"
          done

      - name: Apply pending migrations
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "Applying migrations to Supabase project..."
          SUPPORTS_YES=0
          if supabase db push --help 2>/dev/null | grep -q -- '--yes'; then
            SUPPORTS_YES=1
          fi

          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ inputs.include_all }}" = "true" ]; then
            echo "NOTE: Running with --include-all (requested via workflow_dispatch input)"
            if [ "$SUPPORTS_YES" = "1" ]; then
              supabase db push --include-all --yes
            else
              printf "y\n" | supabase db push --include-all
            fi
          else
            if [ "$SUPPORTS_YES" = "1" ]; then
              supabase db push --yes
            else
              printf "y\n" | supabase db push
            fi
          fi

      - name: Verify migration status
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "‚úì Migrations applied successfully"
          echo "Checking for any pending migrations..."
          supabase migration list || echo "Migration list command not available"

      - name: Regenerate TypeScript types from remote schema
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "üîß Regenerating TypeScript types from remote schema..."
          supabase gen types typescript --linked > lib/types/supabase.ts
          echo "‚úì Types generated from remote schema"

      - name: Check if types need to be committed
        id: check_types
        run: |
          if ! git diff --exit-code lib/types/supabase.ts; then
            echo "types_changed=true" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Types changed after migration deployment"
            echo "This suggests types were not regenerated before merge"
          else
            echo "types_changed=false" >> $GITHUB_OUTPUT
            echo "‚úì Types are already in sync with remote schema"
          fi

      - name: Commit regenerated types
        if: steps.check_types.outputs.types_changed == 'true'
        run: |
          echo "Committing regenerated types..."
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add lib/types/supabase.ts
          git commit -m "chore: regenerate types after migration deployment [skip ci]"
          git push origin HEAD:main
          echo "‚úì Types committed and pushed"

      - name: Query remote migration history
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          SUPABASE_DB_URL: ${{ secrets.SUPABASE_DB_URL }}
        run: |
          echo "üìä Querying remote migration history..."
          
          if [ -n "$SUPABASE_DB_URL" ]; then
            echo "Installing psql..."
            sudo apt-get update -y
            sudo apt-get install -y postgresql-client
            
            echo "Last 5 applied migrations:"
            psql "$SUPABASE_DB_URL" -c "SELECT version, name, inserted_at FROM supabase_migrations.schema_migrations ORDER BY version DESC LIMIT 5;" || echo "Could not query migration history"
          else
            echo "‚ö†Ô∏è  SUPABASE_DB_URL not set, skipping direct DB query"
          fi
          
          echo ""
          echo "‚úÖ Migration deployment complete"

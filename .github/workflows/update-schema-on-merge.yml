name: Update canonical schema on merge

on:
  push:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: update-canonical-schema-main
  cancel-in-progress: true

permissions:
  contents: write

jobs:
  update-schema:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: true

      - name: Exit if triggered by the bot
        if: "github.actor == 'github-actions[bot]'"
        run: |
          echo "Run triggered by github-actions[bot]; exiting to avoid loop."
          exit 0

      - name: Install pg client
        run: sudo apt-get update && sudo apt-get install -y postgresql-client

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Dump schema
        env:
          PG_CONN: ${{ secrets.SUPABASE_DB_URL }}
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          SUPABASE_PROJECT_REF: ${{ secrets.SUPABASE_PROJECT_ID || secrets.SUPABASE_PROJECT_REF }}
        run: |
          set -euo pipefail

          can_use_pg_conn=0
          if [ -n "${PG_CONN:-}" ]; then
            # Determine whether PG_CONN includes a host. If not, pg_dump may fall back to local sockets.
            host=""
            db=""
            if echo "$PG_CONN" | grep -Eq '^postgres(ql)?://'; then
              conn_no_scheme="${PG_CONN#postgresql://}"
              conn_no_scheme="${conn_no_scheme#postgres://}"
              host_and_port="${conn_no_scheme#*@}"
              host_and_port="${host_and_port%%/*}"
              db_part="${conn_no_scheme#*/}"
              db_part="${db_part%%\?*}"
              host="$host_and_port"
              db="$db_part"
              if [ -n "$host" ] && ! echo "$PG_CONN" | grep -Eq '@/?'; then
                can_use_pg_conn=1
              fi
            else
              host="$(echo "$PG_CONN" | sed -nE 's/.*(^|[[:space:]])host=([^[:space:]]+).*/\2/p')"
              db="$(echo "$PG_CONN" | sed -nE 's/.*(^|[[:space:]])dbname=([^[:space:]]+).*/\2/p')"
              if [ -n "$host" ]; then
                can_use_pg_conn=1
              fi
            fi

            if [ "$can_use_pg_conn" -eq 1 ]; then
              echo "Using database host: $host"
              if [ -n "$db" ]; then
                echo "Using database name: $db"
              fi
              pg_dump --dbname="$PG_CONN" -s --no-owner --no-privileges -f schema_new.sql
              exit 0
            fi

            echo "WARNING: SUPABASE_DB_URL is set but missing a host; skipping direct pg_dump."
            echo "Expected format: postgresql://user:***@host:5432/dbname?sslmode=require"
          fi

          if [ -z "${SUPABASE_ACCESS_TOKEN:-}" ]; then
            echo "ERROR: SUPABASE_ACCESS_TOKEN secret is not set"
            echo "Fix: GitHub repo settings -> Secrets -> Actions -> SUPABASE_ACCESS_TOKEN"
            exit 1
          fi
          if [ -z "${SUPABASE_PROJECT_REF:-}" ]; then
            echo "ERROR: Missing Supabase project ref secret"
            echo "Please set either SUPABASE_PROJECT_ID or SUPABASE_PROJECT_REF"
            exit 1
          fi

          echo "Dumping schema via Supabase CLI (linked project)..."
          supabase link --project-ref "$SUPABASE_PROJECT_REF"

          if supabase db dump --help 2>/dev/null | grep -q -- '--schema-only'; then
            supabase db dump --linked --schema-only --file schema_new.sql
          else
            # Older CLI fallback: dump entire DB but keep downstream normalization as-is.
            supabase db dump --linked --file schema_new.sql
          fi

      - name: Normalize schemas and diff
        run: |
          sed '/^--/d' schema_new.sql | sed -E '/^\\\\(un)?restrict /d' | sed '/^$/d' > /tmp/gen.sql
          if [ -f schema/schema.sql ]; then
            sed '/^--/d' schema/schema.sql | sed -E '/^\\\\(un)?restrict /d' | sed '/^$/d' > /tmp/old.sql
          else
            touch /tmp/old.sql
          fi

          if ! diff -u /tmp/old.sql /tmp/gen.sql > /tmp/schema.diff; then
            echo "schema differs, updating schema/schema.sql"
            # Avoid push races: base the commit on the latest origin/main, not the initial checkout SHA.
            cp schema_new.sql /tmp/schema_new.sql
            git fetch origin main
            git checkout main
            git reset --hard origin/main

            mkdir -p schema
            mv /tmp/schema_new.sql schema/schema.sql
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add schema/schema.sql
            git commit -m "ci: update canonical schema after merge" || echo "no changes to commit"

            # Push with a single retry in case main advanced again.
            if ! git push origin main; then
              echo "Push rejected (main moved). Retrying once..."
              git fetch origin main
              git rebase origin/main
              git push origin main
            fi
          else
            echo "No schema changes detected"
          fi
